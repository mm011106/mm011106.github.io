<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tls | MQTT and ...]]></title>
  <link href="http://mm011106.github.io/blog/categories/tls/atom.xml" rel="self"/>
  <link href="http://mm011106.github.io/"/>
  <updated>2015-02-03T20:52:28+09:00</updated>
  <id>http://mm011106.github.io/</id>
  <author>
    <name><![CDATA[Masakazu Miyamoto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[オレオレ証明書を作ってみようかと　実践3]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/03/ore-ore-certificate4/"/>
    <updated>2015-02-03T19:49:16+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/03/ore-ore-certificate4</id>
    <content type="html"><![CDATA[<p>先の投稿でCAを作って、そのキーで証明書にサインしたサーバ証明書を作りました。が、今日何気なくwebを眺めていると”SHA-1は廃止、これからはSHA-2を使いましょう”というような記事があり、ああそう言えば昨日作った証明書はSHA-1でのハッシュ値だったなあと。</p>

<!-- more -->


<p>ということで、作り直します。</p>

<pre><code>$ sudo openssl genrsa 2048 &gt; CA_private_key.pem
$ sudo openssl req -new -sha256 -key ./CA_private_key.pem -x509 -days 7300 &gt; CA_selfsigned_Certificate.pem
</code></pre>

<p>という感じになりますか。</p>

<pre><code class="">$ sudo openssl x509 -text &lt; CA_selfsigned_Certificate.pem
</code></pre>

<p>で確認してみると、たしかにSHA256でハッシュが作られている、と書いてありました。</p>

<p>これでok。</p>

<blockquote><p>SHA-1は2005年に脆弱性が問題になり、2010年までにSHA-2に移行するように要請されていたようです。で、何が問題かというと、webを読みかじったところによると、SHA-1でつくったハッシュは「あるファイルと同じハッシュになるファイルを作れる時間」が当初思っていたよりも速く（短い時間で）できることがわかったそうで、同じハッシュを持った違うファイルを作ることが比較的簡単に可能になります。そうすると、サインした証明書の中身をすげ替えてもわからない、ということが起こるようです。</p>

<p>ここらへんの周辺事情は検索すると山ほど引っかかるので、読み物としては面白いですね。</p></blockquote>

<p>また、元々の鍵のクオリティを上げる（ランダム性を上げる？）ために、乱数をパラメタとして与える、というのもあるようです。</p>

<pre><code>$ sudo openssl md5 /var/log/syslog* &gt; rand.dat
$ sudo openssl genrsa -rand ./rand.dat -aes256 2048 &gt; CA_private_key.pem  
</code></pre>

<p>と言った感じです。syslogのファイルのMD5ハッシュ値を計算してそれを乱数の種にするように指定します。</p>

<p>さらに、鍵をAES256で暗号化する指定を入れています。</p>

<p>なんか、この暗号の世界はかなりな勢いで世代替わりがあるようですね。現在「最高性能」といわれているものが５年後には「廃止」になっているかもしれないです。
そういう意味でも、数年に一度ぐらいの間隔で証明書を作りなおすのもいいかもしれませんね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オレオレ証明書を作ってみようかと　実践2]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/02/ore-ore-certificate3/"/>
    <updated>2015-02-02T20:41:28+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/02/ore-ore-certificate3</id>
    <content type="html"><![CDATA[<p>先の投稿では「オレオレ証明書」を作って、無事nginxに導入してTLS接続が出来るようになりました。<br/>
あとはこれをmosquittoに応用するだけ、と思っていたら実はCA certificate（CA証明書）が必要だと言うことにはたと気づき、がっくり。</p>

<!-- more -->


<p>結局、</p>

<ul>
<li>認証局(CA)を作る</li>
<li>その認証局の鍵でサーバの証明書にサインしてもらう</li>
</ul>


<p>と言う手順をとる必要があります。<br/>
認証局と行っても、自己証明書ということでは先に作ったサーバの証明書と同じです。</p>

<h2>自前のCAを作る</h2>

<p>基本的には、サーバの自己証明書を作るのと同じ手順で認証局の証明書（CA certificate)をつくります。手順としては</p>

<ul>
<li>CAの鍵を作る　(CA key)</li>
<li>自己署名の証明書を作る　（これがCAの証明書（CA certificate)になる）</li>
</ul>


<p>となります。 ここでは、CAの鍵をCA_private_key.pem,　CAの証明書をCA_selfsigned_Certificate.pemというファイル名を付けました。</p>

<p>実は、これがいっぺんにできるそうで、これが以下のコマンド。</p>

<pre><code>$ sudo openssl req -new -x509 -newkey rsa:2048 -keyout CA_private_key.pem -days 7300 &gt; CA_selfsigned_Certificate.pem
</code></pre>

<p>このなかで、</p>

<ul>
<li>鍵を作って</li>
<li>リクエスト用のファイルを作って</li>
<li>それに対して自分でサインして</li>
</ul>


<p>という3つのことが行われているようです。</p>

<p>このコマンドでは、キーを暗号化するためのパスフレーズを要求されます。さらに、証明書に記載するための情報（組織名とか所在地とか）を聞かれますので、適宜答えていきます。</p>

<p>最初、以下の様なコマンドでも良いはずですが、パスフレーズを入力するところがでません。確認してみると、鍵は暗号化されていないようです。</p>

<pre><code>$ sudo openssl genrsa 2048 &gt; CA_private_key.pem
$ sudo openssl req -new -key ./CA_private_key.pem -x509 -days 7300 &gt; CA_selfsigned_Certificate.pem
</code></pre>

<p>manでしらべてみると、genrsaのオプションで -des3とか暗号化のオプションを付けないためパスフレーズを聞かれないようです。暗号化する指示をすればパスフレーズを聞いてきました。理由が分かれば当たり前の話。<br/>
なので、最初の鍵を作るコマンドは</p>

<p><code>$ sudo openssl genrsa -des3 2048 &gt; CA_private_key.pem</code></p>

<p>とするのが、安全性の面でも良い感じですかね。</p>

<p>これでCA鍵とCA証明書ができあがりです。「俺様認証局」ですね。この鍵でいくらでも「オレオレ」証明書がつくれます。</p>

<p>会社内、組織内のセキュア接続のためには有効につかえるかな、とおもいます。ただ鍵が流出するといくら社内用といえどもセキュリティ的に問題があるので、きちんと管理しないといけません。鍵には名前も書いてありますしね。</p>

<h2>サーバの証明書にサインする</h2>

<p>それでは、サーバの証明書を作ってみます。</p>

<p>最初にサーバに設置する証明書のための鍵をつくります。さらに、その鍵をもとに証明書署名リクエストファイルを作成します。まあ、申請書みたいな物ですね。これは、前回の<a href="http://mm011106.github.io/blog/2015/01/31/ore-ore-certificate2/">オレオレ証明書を作ってみようかと　実践１</a>を参考にしてください。この記事の１．２．を実行してもらうといいとおもいます。</p>

<p>ここでは、署名リクエストファイルをmyserver.csr、署名付き証明書をmyserver.crtとします。</p>

<p>サーバの証明書にCAのサインをするので、myserver.csrとCA_selfsigned_Certificate.pem（CA証明書）, CA_private_key.pem（CA鍵）が必要になります。</p>

<p>具体的には、</p>

<pre><code>$ sudo openssl x509 -CA CA_selfsigned_Certificate.pem -CAkey CA_private_key.pem -req -days 7300 -CAcreateserial &lt; myserver.csr &gt; myserver.crt
</code></pre>

<p>とします。ここで、-daysはサインする証明書の有効日数、-CAcreateserialは最初に署名するときだけ必要なオプション。これをやるとシリアル番号のファイルが出来るそうな。</p>

<p>これだけで、サーバの証明書にCAのサインをしてサーバに設定出来る証明書ができあがりました。</p>

<p>nginxに入れて動作を確認しました。</p>

<p>ブラウザから証明書を確認すると、「発行者名」と「サブジェクト名」がそれぞれ、CA証明書を作るときに入力した情報、myserverの証明書（証明書署名リクエストファイル）作るときに入力した情報になっているはずです。</p>

<p>ここでもう少しきちんとしたい人は、CA証明書をブラウザに読み込むことで、「この証明書は不明な機関によって署名されています」的なメッセージを回避できます。この作業はこの証明書を信じます、と言う宣言ですので、もしこの鍵が悪用されたりすると大変なことになる可能性があります。鍵の管理はしっかりしておきましょう。</p>

<p>信じてもらうためにはしっかりと行動するということですね。人生。</p>

<p>mosquittoではブローカがcertificateを提供してくるので、それが正しいかどうか確認するための認証局の証明書が必要になります。webブラウザなんかだと、パブリックな認証局の情報は一通りはいっていますから普段認証局のcertificateを意識することは無いですよね。</p>

<p>きょうは、ここまでです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オレオレ証明書を作ってみようかと　実践１]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/31/ore-ore-certificate2/"/>
    <updated>2015-01-31T20:29:12+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/31/ore-ore-certificate2</id>
    <content type="html"><![CDATA[<p>先に投稿した、オレオレ証明書の続きです。</p>

<p>今回は、実際の証明書を作りwebサーバに導入して動作確認までやって見ました。</p>

<!-- more -->


<h2>オレオレ証明書を作る</h2>

<p>いったいどこから手を付ければ良いか分からないので、検索してみます。
いろいろなところで例が示されていますが、opensslで作れそうな感じです。とくに<a href="http://d.hatena.ne.jp/ozuma/20130511/1368284304">こちらのページ</a>に非常にわかりやすくまとめられていましたので、こちらをそのまま順番に試していこうと思います。</p>

<p>詳しい解説は、そちらをご覧ください。</p>

<h3>1.秘密鍵を作る</h3>

<p>まずは、秘密鍵(server.key)を作ります。</p>

<pre><code class="sh ">$ openssl genrsa 2048 &gt; server.key
</code></pre>

<p>これで2048bitのRSAキーが作られます。参考ページの解説によると、この情報の中に暗号化に必要な全てのものが入っています。ここから公開鍵も作られます。</p>

<p>中身を見てみます。</p>

<pre><code class="sh ">$ openssl rsa -text &lt; server.key 
Private-Key: (2048 bit)
modulus:
  :
  :
</code></pre>

<p>見てもよく分かりませんが、なんか出来てます。</p>

<h3>2.証明書署名リクエストファイルを作る</h3>

<p>次に、証明書にサインしてもらうためのリクエストファイルを作ります。
このファイルには、秘密鍵から作られた公開鍵と秘密鍵のハッシュ値（鍵の情報を要約した物）が入っています。さらに証明書に記載する署名情報（サーバのFQDNとか組織名とか）が加わります。</p>

<pre><code class="sh ">$ openssl req -new -key server.key &gt; server.csr
</code></pre>

<p>このときに、サーバのFQDNや組織名、所在地など聞かれます。適当で良いようですが、サーバのFQDNはきちんと入れておいた方が良いようです。証明書のFQDNとそれを設置したサーバのFQDNが違うのはダメなような気がしますね。</p>

<p>再び内容を確認します。</p>

<pre><code class="sh ">$ openssl req -test &lt; server.csr 
</code></pre>

<h3>3.認証局に成り代わって、証明書にサインします</h3>

<p>できあがった証明書署名リクエストファイルに署名をして正式な証明書にします。<br/>
本来これは認証局がやることですが、「おれおれ」なので「おれ」が証明書にサインします。</p>

<pre><code class="">openssl x509 -req -days 7300 -signkey server.key &lt; server.csr &gt; server.crt
</code></pre>

<p>-days オプションでは有効期限を指定します。ここでは7300日、20年、だいたい私が死ぬまで有効。</p>

<p>できあがりを確認してみます。</p>

<pre><code>$ openssl x509 -text &lt; server.crt 
</code></pre>

<p>先ほど入力した組織名やFQDNが見えてくると思います。</p>

<p>必要なファイルは、.crtファイル（証明書）と.key（秘密鍵）です。
両方ともownをrootにして、パーミッションを600に設定しておきます。</p>

<h2>まずはwebサーバに設定してみる</h2>

<p>先のwebcamの投稿でnginxをインストールしましたが、このサーバに作った鍵を設定して試してみます。</p>

<p>これも、設定方法を検索したところ、そのものずばり<a href="http://heartbeats.jp/hbblog/2012/06/nginx06.html">&ldquo;nginxのTLS設定&rdquo;</a>というページが見つかりました。この連載、とてもわかりやすくnginxの設定方法が書かれていますので、あとでよく勉強しておこうと思います。</p>

<p>やることとしては、configファイルを変更してhttpsの受け口を作り、そこに先ほど作った証明書をいれる、ということになります。</p>

<p>設定ファイルは、先のページを参考に以下の様にしました。</p>

<pre><code class="sh /etc/nginx/sites-sites-available/default">server {
    listen 443 ssl;
    server_name my.www.server.jp;
    root /home/mynginx/www;
    index index.html index.htm;

    ssl_certificate /etc/nginx/server.crt;
    ssl_certificate_key /etc/nginx/server.key;

    ssl_session_timeout 5m;
    ssl_session_cache shared:SSL:10m;

    ssl_protocols SSLv3 TLSv1;
    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv3:+EXP;
    ssl_prefer_server_ciphers on;

    location / {
        try_files $uri $uri/ =404;
        auth_basic "Restricted";
        auth_basic_user_file /etc/nginx/.htpasswd;
    }
}
</code></pre>

<ul>
<li>httpsのポートを443に設定してsslを有効にします。</li>
<li>サーバのFQDNを設定</li>
<li>webサーバのドキュメントルートを設定</li>
<li>証明書と秘密鍵を指定</li>
<li>タイムアウトとキャッシュを設定（ここら辺は参考webページの写しです）</li>
<li>SSLのプロトコル指定と暗号化スイートの指定です。ここら辺はnginxのデフォルト設定ファイルのコピー</li>
<li>ドキュメントの特定の場所のビヘイビアの指定です。ここではルート以下の全てのアクセスでBasic認証を要求するような設定です</li>
</ul>


<p>認証のために.htpasswdが必要になりますが、これはhttp-toolsのなかにあるhtpasswdコマンドでつくりました。</p>

<pre><code class="sh how-to make a password file">$ sudo htpasswd -c .htpasswd UserName
New password:
Re-type new password:
</code></pre>

<p>のようにしてパスワードファイルを作成して、設定します。</p>

<h3>4.設定を有効にして、再起動</h3>

<p>設定を書き終えたら設定を確認して、読み込ませます。</p>

<pre><code class="sh restart nginx">$ sudo nginx -t
$ sudo nginx -s reload
</code></pre>

<h3>5.動作確認</h3>

<p>これで、TLSが有効になっているはずです。アクセスしてみます。</p>

<p><code>https://my.www.server.jp</code></p>

<p>ブラウザからは「この証明書は無効です」などのワーニングが出てきました。証明書に有効なサインがない、サインした人が「ちゃんとした」人じゃ無いので、このようにワーニングがでます。
出てきたワーニングから「証明書を確認する」などのボタンをおして、自分が作った証明書だということを確認します。</p>

<p>確認できたら、ワーニングを無視して進みます。
ここでログイン（Basic認証）のポップアップが出てくるはずです。先ほど設定したログイン名とパスワードを入力します。無事ログインして、webページがみれました。</p>
]]></content>
  </entry>
  
</feed>
