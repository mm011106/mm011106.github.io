<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mqtt | MQTT and ...]]></title>
  <link href="http://mm011106.github.io/blog/categories/mqtt/atom.xml" rel="self"/>
  <link href="http://mm011106.github.io/"/>
  <updated>2014-12-14T09:39:36+09:00</updated>
  <id>http://mm011106.github.io/</id>
  <author>
    <name><![CDATA[Masakazu Miyamoto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[max_queued_messagesオプションの動作]]></title>
    <link href="http://mm011106.github.io/blog/2014/12/07/max-quieued-messages/"/>
    <updated>2014-12-07T10:14:05+09:00</updated>
    <id>http://mm011106.github.io/blog/2014/12/07/max-quieued-messages</id>
    <content type="html"><![CDATA[<p>ということで、先の<code>max_queued_messages</code>オプションを試してみました。</p>

<p>結論から言うと、バッファリングしているのは<strong>指定した数の最も古いデータ</strong>でした。</p>

<!-- more -->


<p>確認手順：</p>

<ul>
<li><p>mosquitto.confに<code>max_queued_messages 30</code>と設定<br/>
これで、30個のデータが保持されるはず。</p></li>
<li><p>ブローカが動いている計算機から <code>$ sudo /etc/init.d/mosquitto restart</code>　で設定を反映</p></li>
<li><p>QoS１、clear_sessionをfalseでブローカにサブスクライブ要求します。</p></li>
<li><p>適当に中断</p></li>
<li><p>適当に再開<br/>
今回は寝る前に止めて朝起きて再接続してみました。<br/>
あとでデータを確認できるよう<code>reconnect.txt</code>というファイルに保存。データの第一フィールドは送信時のタイムスタンプになっています。</p></li>
</ul>


<p>で、送られたデータを確認してみると。。。。</p>

<pre><code class="sh">$ cat reconnect.txt | awk -F , '{ command = "date -d @" $1 ; printf NR"   " ; system(command) }'
1   Sat Dec  6 21:33:01 JST 2014
2   Sat Dec  6 21:34:02 JST 2014
3   Sat Dec  6 21:35:01 JST 2014
  (...snip..)
27   Sat Dec  6 21:59:01 JST 2014
28   Sat Dec  6 22:00:01 JST 2014
29   Sat Dec  6 22:01:01 JST 2014
30   Sat Dec  6 22:02:02 JST 2014 &lt;指定した数だけ古いデータがあって
31   Sun Dec  7 09:57:01 JST 2014 &lt;そのあと最新の配信データが届く
32   Sun Dec  7 09:58:02 JST 2014
</code></pre>

<p>ということで、停止してすぐのデータが指定数だけ保存されている、という結論です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mosquitto.conf 再び]]></title>
    <link href="http://mm011106.github.io/blog/2014/12/06/again/"/>
    <updated>2014-12-06T19:58:41+09:00</updated>
    <id>http://mm011106.github.io/blog/2014/12/06/again</id>
    <content type="html"><![CDATA[<p>昨日の、通信が途絶えている時にブローカがためておいてくれる件、<code>mosquitto.conf</code>にはこんなオプションがありました。</p>

<ul>
<li><strong>max_queued_messages</strong></li>
</ul>


<!-- more -->


<pre><code class="sh"># The maximum number of QoS 1 and 2 messages to hold in a queue 
# above those that are currently in-flight.  Defaults to 100. Set 
# to 0 for no maximum (not recommended).
# See also queue_qos0_messages.
#max_queued_messages 100
</code></pre>

<p>データ送信のキューに長さの最大を指定します。これ以上になったらどうなるのかなあ？古いやつから捨てられるのかしら？</p>

<p>さらに max_inflight_messagesというのもあって、こちらは通信中(?)の最大メッセージ数を規定します。</p>

<p>client IDの件に関連するオプションでこんなものもありました。</p>

<ul>
<li><strong> allow_zero_length_clientid </strong></li>
</ul>


<pre><code class="sh"># This option controls whether a client is allowed to connect with a zero
# length client id or not. This option only affects clients using MQTT v3.1.1
# and later. If set to false, clients connecting with a zero length client id
# are disconnected. If set to true, clients will be allocated a client id by
# the broker. This means it is only useful for clients with clean session set
# to true.
#allow_zero_length_clientid true
</code></pre>

<p>client IDなしで接続できるかどうか、を設定するオプションかと思われます。ここに書いてあるようにIDを設定してしまうと、サブスクライブ接続を切った時に、それがテンポラリーなのかパーマネントなのかブローカは知る由がありません。そのため、同じIDで再接続されると切断されていた期間のデータが送られてきます。それは不要、という時もありますよね。。。。</p>

<p>今のところの対処は、一度 QoS0で再接続してから切る、というのをやっています。こうすると次に接続した時は接続後の情報から入手できます。ほんとはもっといい手があるのかとも思いますが。</p>

<p>ココらへんは、データアクイジションの側であれば、あとから不要な部分を切り取るとか、いかようにでも処理できるかと思います。コマンド系の接続では重要なポイントになりそうなので、考慮の必要がありそうですね。タイムスタンプを確認するとか。</p>

<p>などと話していたら、こんなオプションがありました。</p>

<ul>
<li><strong>persistent_client_expiration</strong></li>
</ul>


<pre><code class="sh"># This option allows persistent clients (those with clean session set to false)
# to be removed if they do not reconnect within a certain time frame.
#
# This is a non-standard option in MQTT V3.1 but allowed in MQTT v3.1.1.
#
# Badly designed clients may set clean session to false whilst using a randomly
# generated client id. This leads to persistent clients that will never
# reconnect. This option allows these clients to be removed.
#
# The expiration period should be an integer followed by one of d w m y for
# day, week, month and year respectively. For example
#
# persistent_client_expiration 2m
# persistent_client_expiration 14d
# persistent_client_expiration 1y
#
# The default if not set is to never expire persistent clients.
#persistent_client_expiration
</code></pre>

<p>persistentは「しつこい」という意味らしいですが、長い接続は強制的に解除するということのようです。
「ランダムのidを使っていながらclean session（切断時の送信データを破棄してもらうモード）をfalseで接続してくるたちの悪いクライアント」とありますね。そういう接続はしないように設計します。はい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[disable-clean-sessionオプション]]></title>
    <link href="http://mm011106.github.io/blog/2014/12/05/mosquitto-sub-c-option/"/>
    <updated>2014-12-05T21:14:40+09:00</updated>
    <id>http://mm011106.github.io/blog/2014/12/05/mosquitto-sub-c-option</id>
    <content type="html"><![CDATA[<p>一昨日から気になっていた<a href="http://mosquitto.org/man/mosquitto_sub-1.html"><code>mosquitto_sub --disable-clean-session</code></a>オプションですが、試してみました。</p>

<p>ブローカに向かって<code>--desiable-clean-session</code>と<code>--id</code>の2つのオプションをつけてサブスクライブを要求します。</p>

<!-- more -->


<pre><code class="sh">$ mosquitto_sub -h HOSTNAME -t YOUR/TOPIC/NAME --qos 1 --disable-clean-session --id CONNECTION-ID

1417781342, 1691, 0, 0, 0
1417781402, 1691, 0, 0, 0
1417781461, 1691, 0, 0, 0
1417781522, 1691, 0, 0, 0　　&lt;&lt;時刻 21:12:02　で中断
^C
</code></pre>

<p><code>--id</code>オプションはサブスクライバが同一であることを主張するためのもののようですので、これが一致することで「再接続だから配信していないデータを送らなきゃ」と認識してくれます。<code>--id</code>を指定しないとデフォルトのプロセス番号を元にしたものになるので、プロセスを止めて再度起動した場合「再接続」と認識してもらえません。
また、&ndash;qosが1もしくは2でないとダメみたいです。QoS　0は配信保証がなされないクオリティ指定ですので、当然といえば当然。</p>

<p>データが来たところで、適当に中断します。このトピックではパブリッシャが1分毎に1データを送ってきます。データの最初のフィールドがエポックタイムです。よく見ると60づつ増えていっているのがわかります。</p>

<p>そしてCtrl-Cでプロセスを止めます。</p>

<p>では、ここでしばらく待って。。。。。</p>

<p>わかりやすいように、タイムスタンプを印刷してからサブスクライブを再開します。</p>

<pre><code class="sh">$ date ; mosquitto_sub -h __host-name__ -t YOUR/TOPIC/NAME --qos 1 --disable-clean-session --id  testclient

Fri Dec  5 21:24:54 JST 2014
1417781581, 1692, 0, 0, 0　　&lt;&lt;　再開したのは21:24:54だけど、21:13:01のデータから配信されている。
1417781642, 1691, 0, 0, 0
1417781701, 1691, 0, 0, 0
1417781761, 1692, 0, 0, 0
1417781822, 1691, 0, 0, 0
1417781881, 1691, 0, 0, 0
1417781942, 1692, 0, 0, 0
1417782002, 1692, 0, 0, 0
1417782061, 1692, 0, 0, 0
1417782121, 1692, 0, 0, 0
1417782182, 1692, 0, 0, 0
1417782241, 1692, 0, 0, 0
1417782302, 1692, 0, 0, 0
1417782361, 1692, 0, 0, 0
   ：
   :
</code></pre>

<p>おお、きちんと中断している間のデータも配信されました。</p>

<p><code>--id</code>オプションには次のように書かれています。</p>

<p><strong> -i, - -id </strong></p>

<blockquote><p>The id to use for this client. If not given, defaults to mosquitto_sub_ appended with
the process id of the client. Cannot be used at the same time as the <strong> <em>&ndash;id-prefix</em> </strong> argument.</p></blockquote>

<p>通常、IDは<code>mosquitto_sub_${PID}</code>になるようです。でもpidは起動するたびに変わってしまうので、同じクライアントとは認識されませんね。物理経路のトラブル等で通信が途絶えた場合は大丈夫でしょうけれど。</p>

<p><code>--id-prefix</code>はプリフィックスを固定してしまうオプションなので、<code>--id</code>とは共存できないということですね。</p>

<p>関連するところで<br/>
ブローカの方の設定で<code>clientid_prefixe</code>というのがあるのですが、これを設定（mosquitto.conf内）すると、指定したプリフィックスのついたクライアントしか接続出来ないようにできるようです。</p>

<p><strong>clientid_prefixes</strong> <em>prefix</em></p>

<blockquote><p>If defined, only clients that have a clientid with a prefix that matches clientid_prefixes will be
allowed to connect to the broker. For example, setting <em>&ldquo;secure-&rdquo;</em> here would mean a client
&ldquo;<em>secure-</em>client&rdquo; could connect but another with clientid &ldquo;mqtt&rdquo; couldn&rsquo;t. By default,
all client ids are valid.</p></blockquote>

<p>となるようです。セキュリティの一助になるかしら？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mosquitto.confを見てみた]]></title>
    <link href="http://mm011106.github.io/blog/2014/12/04/mosquitto-dot-conf/"/>
    <updated>2014-12-04T20:21:14+09:00</updated>
    <id>http://mm011106.github.io/blog/2014/12/04/mosquitto-dot-conf</id>
    <content type="html"><![CDATA[<p>やっぱりmanは見ないとダメ、ということで、まずは<code>mosquitto.conf</code>を紐解いています。
原文はこちら<a href="http://mosquitto.org/man/mosquitto-conf-5.html"><code>man mosquitto.conf(5)</code></a></p>

<p>つらつらとながめていると、昨日疑問に思っていた部分が書かれていました。</p>

<!-- more -->


<p><strong>mount_point</strong>  <em>topic prefix</em></p>

<blockquote><p>This option is used with the listener option to isolate groups of clients.
When a client connects to a listener which uses this option, the string argument is attached to the start of all topics for this client. This prefix is removed when any messages are sent to the client. This means a client connected to a listener with mount point <em><strong>example</strong></em> can only see messages that are published in the topic hierarchy <em><strong>example</strong></em> and above.</p></blockquote>

<p>さらに、<code>mosquitto.conf</code>のデフォルトでは、この部分が</p>

<pre><code># The listener can be restricted to operating within a topic hierarchy using
# the mount_point option. This is achieved be prefixing the mount_point string
# to all topics for any clients connected to this listener. This prefixing only
# happens internally to the broker; the client will not see the prefix.
#mount_point
</code></pre>

<p>となっています。</p>

<p>「クライアント」と「リスナー」という言葉が出てきて？？？な感じです。。。。</p>

<blockquote><p>The network ports that mosquitto listens on can be controlled using listeners.</p></blockquote>

<p>とあるので、ブローカーがパブリッシャからの聞き耳を立てるポートをコントロールするためのものが「リスナー」なんでしょうか。どうも、そうみたいですね。
「リスナー」は、MQTTのプロトコルを通信するためのポートに、この設定ファイルで設定できるようなメソッドを組み込んだオブジェクトみたいな感じでしょうか。</p>

<p>その「リスナー」の部分、<code>mosquitto.conf</code>では</p>

<pre><code class=""># Listen on a port/ip address combination. By using this variable 
# multiple times, mosquitto can listen on more than one port. If 
# this variable is used and neither bind_address nor port given, 
# then the default listener will not be started.
# The port number to listen on must be given. Optionally, an ip 
# address or host name may be supplied as a second argument. In 
# this case, mosquitto will attempt to bind the listener to that 
# address and so restrict access to the associated network and 
# interface. By default, mosquitto will listen on all interfaces.
# listener port-number [ip address/host name]
#listener
</code></pre>

<p>となっているので、ポートを「リスナー」として設定して開けば、その一つ一つに個別のマウントポイントを設定できる、という感じですかね。でもサブスクライバの方はどうなるんでしょ？サブスクライブできるトピックを限定できるのかなあ。そうか、ポート毎（リスナー毎）にマウントポイントを設定できればそのポート（リスナー）のサブスクライバは全部そのマウントポイントしか見えない、ってことか。パブリッシャも同様。
listenerごとにipアドレスやホストネームをバインドできるのはそのためですかね。とすれば、IPアドレスは複数設定できなきゃいけませんね。。。。</p>

<p>その他セキュリティ設定のところでも、特定のトピックの読み書きが可能なように設定できたりするようです。</p>

<p>そもそも「クライアント」はサブスクライバとパブリッシャの両方のことを意味するのかしら？？？</p>

<p>奥深し。。。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mosquitto_subのオプション]]></title>
    <link href="http://mm011106.github.io/blog/2014/12/03/mqtt-option/"/>
    <updated>2014-12-03T20:43:00+09:00</updated>
    <id>http://mm011106.github.io/blog/2014/12/03/mqtt-option</id>
    <content type="html"><![CDATA[<p>今日も何気なく検索しながら、webを眺めていたら、<code>mosquitto_sub</code>のこんなオプションを発見。</p>

<p><strong><code>-c, --disable-clean-session</code></strong></p>

<!-- more -->


<p>
</p>

<p><code>Disable the 'clean session' flag. This means that all of the subscriptions for the client will be maintained after it disconnects, along with subsequent QoS 1 and QoS 2 messages that arrive. When the client reconnects, it will receive all of the queued messages.</code>
<code>If using this option, it is recommended that the client id is set manually with --id</code></p>

<p>これがちゃんと動けば、結構いいですよねえ。でもまあ、ちゃんと<code>man</code>読めよ、って話ですな。</p>

<p>週末に試してみよう。</p>

<p>ところで全く話は違いますが、<code>mosquitto(8)</code>では1つのブローカのプロセスで1つのトピックツリーを持っているのですよね。
もし、1つのブローカを多くのユーザが共有した場合、お互いのトピックツリーは自由に行き出来できてしまいますよねえ。多くのユーザで使いたいときはどうすればいいのかなあ、と思っていた次第。
<code>-iオプション</code>でユーザ名を指定すればユーザ名ごとにトピックツリーを作ってくれるのかしら？</p>

<p>これも試す必要があります。</p>
]]></content>
  </entry>
  
</feed>
