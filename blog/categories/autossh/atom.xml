<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: autossh | MQTT and ...]]></title>
  <link href="http://mm011106.github.io/blog/categories/autossh/atom.xml" rel="self"/>
  <link href="http://mm011106.github.io/"/>
  <updated>2015-02-23T22:49:59+09:00</updated>
  <id>http://mm011106.github.io/</id>
  <author>
    <name><![CDATA[Masakazu Miyamoto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[autosshでポートフォワード]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/21/autossh-2/"/>
    <updated>2015-02-21T18:16:46+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/21/autossh-2</id>
    <content type="html"><![CDATA[<p>以前、ポーフォワードを<a href="http://mm011106.github.io/blog/2015/01/12/autossh/">autosshで設定する</a>というのをやりましたが、今回はそれをもう少しまとめてみました。<br/>
起動スクリプトの理解を少し深めて、さらにポートフォワード用のユーザを作ってそこで実行するようにして見ました。</p>

<!-- more -->


<h2>何をするのか？</h2>

<p>今回の目標は、エッジデバイス側の暗号化経路を確立するために、システム起動時にサーバ（ここではブローカ）にsshでポートフォワードを設定することです。
さらにセキュリティ向上を目指して、ポートフォワードのプロセスを起動する専用のユーザを設定しています。</p>

<p>手順としては、</p>

<ul>
<li>ユーザを作る</li>
<li>そのユーザ上にsshのconfigファイルを設定</li>
<li>パスフレーズなしの鍵を作る</li>
<li>接続テスト</li>
<li>init.d用スクリプトを作成〜登録</li>
<li>起動テスト</li>
</ul>


<p>となりました。</p>

<p>以下のパラメタを決定しておきます。
()内には、この例での値を書いておきます。</p>

<ul>
<li>サーバ名(mybroker)</li>
<li>サーバのアカウント名(pipipi)</li>
<li>サーパのsshポート(sshport)</li>
<li>サーバのMQTTポート(1883)</li>
<li>パスフレーズなしの鍵 (mqttclient_key)</li>
<li>ローカルのMQTT用ポート(22883)</li>
<li>ポートフォワード用ユーザ(pfuser)</li>
</ul>


<p>ハードウエアはRaspberry Pi、OSはRaspbianを想定しています。</p>

<h2>ポートフォワード用ユーザを作成</h2>

<p>まずは、ポートフォワード用ユーザを作ります。</p>

<pre><code class="sh"> $ sudo useradd -m pfuser
</code></pre>

<p>このオプションだとユーザのホームディレクトリだけが作成されます。パスワードが設定されていませんので、ログインできない状態（ロック状態）となっています。<br/>
ユーザ設定のデフォルト値は<code>useradd -D</code>で表示できるようですので、確認しておきましょ。</p>

<p>このユーザにはログインできない状態のはずです。一応、外からsshで接続してみます。。。。<br/>
やはりできませんね。ok<br/>
さらに、コマンドからユーザの設定を確認しておきます。</p>

<pre><code class="sh"> $ passwd -S pfuser
pfuser L 02/21/2015 0 99999 7 -1
</code></pre>

<p>2番目にLとありますが、これがロックされているアカウント、という意味のようです。</p>

<p>次に、作ったユーザのホームディレクトリに以下のものを作ります。</p>

<ul>
<li>パスフレーズなしの鍵</li>
<li>ssh用のconfiファイル作成</li>
</ul>


<h2>パスフレーズなしの鍵を作る</h2>

<p>他のユーザで鍵を作ってコピーしてもいいですが、ユーザ名の変更とかしなきゃいけない(<code>chown usr:grp</code>)ので、素直にポートフォワード用ユーザ(pfuser)に移動して鍵を作ります。</p>

<pre><code class="sh">$ sudo su - pfuser
# 今のユーザからpfuser（今作ったポートフォワード用ユーザ）に移動
# '-' optionでログインしたのと同じ状態
#  （ホームに移動して環境変数も初期化される）になる

$ mkdir .ssh
$ cd .ssh
$ ssh-keygen -f mqttclient_key 
# パスフレーズを入力するように言われますが、ただenterを押してやることで
# パスフレーズなしの鍵ができます
</code></pre>

<p>(以後しばらくこのユーザで作業します。)</p>

<p>作った鍵の公開鍵の方を(<code>mqttclient_key.pub</code>)をサーバ側にコピーします。</p>

<pre><code class="sh">$ scp -P sshport ./mqttclient_key.pub pipipi@mybroker:~/.ssh/
$ ssh pipipi@mybroker
mybroker $ echo -n 'no-pty,permitopen="localhost:1883",command="/bin/false" ' &gt;&gt; authorized_keys
# これは、パスフレーズなしの鍵でログインした場合の動作を制限するおまじないです。
mybroker $ cat .ssh/mqttclient_key.pub &gt;&gt; authorized_keys 
# 鍵を登録します
mybroker $ exit
</code></pre>

<p>これで、サーバに鍵を登録しましたので、試しに接続してみます。</p>

<pre><code class="sh">$ ssh -i ~/.ssh/mqttclient_key pipipi@mybroker
PTY allocation request failed on channel 0
Connection to xxx.xxx.xxx.xxx closed.
</code></pre>

<p>となれば成功です。これは、先程の鍵の登録の時のおまじないで、コンソールが開かないようにno-ptyでオフにしたこと、またコマンド入力を受け付けないようにシェルを空のシェルプログラムにしたことでコネクションがフェイルしているためです。</p>

<h2>sshの設定ファイルを作る</h2>

<p>次に、sshのポートフォワード設定ファイルをつくります。コマンドラインからすべてのパラメタを入れてもいいのですけれど、結構長くなってしまうのと、psでプロセスを表示した時にパラメタが全部見えてしまうのでなんとなく気持ち悪いのでこうします。</p>

<p>viなどのエディタで以下のような内容のファイルを<code>~/.ssh/config</code>として作ります。</p>

<pre><code class="sh">#
#  MQTT portforwarding config
#

ServerAliveInterval   30
ServerAliveCountMax   3

StrictHostKeyChecking  no

Host Broker
  HostName        mybroker
  IdentityFile    /home/pfuser/.ssh/mqttlient_key
  User            pipipi
  LocalForward    22883 localhost:1883
  Port            sshport 
</code></pre>

<p>このようにすることで、sshのマンドオプションに&#8217;Broker&#8217;と指定するだけで接続できるようになります。</p>

<p>最初の2行の設定は、コネクションを確認するための設定で、</p>

<blockquote><p>30秒に1回コネクションがあることを確認するためのパケットを送ります。もしこれが3回繰り返して通らない場合（コネクションがダウンしている場合）、接続を切ります。</p></blockquote>

<p>という設定です。</p>

<p>つまり、これで30秒x3=1分30秒間連続してコネクションが切れていると、sshはダウンします。</p>

<p>StrictHostKeyCheckingはクライアント側のknown_hostsに接続先の登録がないときに「ほんとに接続していいのかよ」と聞いてくるのを抑えます。このメッセージが出てしまうとスクリプトで実行した時にエラーで止まってしまいます。今回の場合は明示的に鍵をサーバにコピーしていますし、騙されたりして違うサーバに接続することはないと思うので、このように指定しました。</p>

<p>Host以降は接続名に対応する設定を記入します。IdentityFileはフルパスのほうが後々トラブルが少ないとおもうので、そうしておきました。</p>

<p>ここまでできたら、このconfigファイルを使って接続を試してみます。</p>

<pre><code class="sh">$ ssh -f -N -F /home/pfuser/.ssh/config Broker
</code></pre>

<p>-f は起動後バックグラウンドに移動させるためのオプションです。-N は接続先でコマンドを起動しない設定です。<br/>
エラーせずプロンプトが帰ってくれば成功している可能性大です。psコマンドで確認してみます。</p>

<pre><code class="sh">$ ps ax | grep 'ssh'
 3100 ?        S      0:00 ssh -f -N -F /home/pfuser/.ssh/config Broker
</code></pre>

<p>のように先のコマンドラインが出てくればokです。</p>

<p>exitして元のユーザに戻っておきます。</p>

<h2>init.d用のスクリプトを書く</h2>

<p>これがちょっと曲者なので、検索して<a href="http://files.bogosity.se/autossh_tunnel.foo">動きそうなスクリプト</a>を探してきました。これに適宜必要な部分を書きたして見ました。</p>

<p>ファイル名を<code>mqtt-pf</code>として下記の内容を<code>/etc/init.d/</code>に作成します。</p>

<p>su でやる必要がありますので、念の為。</p>

<p><a href="https://raw.githubusercontent.com/mm011106/mqtt-pf/master/mqtt-pf">mqtt-pf</a></p>

<pre><code class="sh ">#! /bin/sh
### BEGIN INIT INFO
# Provides:          mqtt-pf
# Required-Start:    $syslog $network $all 
# Required-Stop:     $syslog $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Port forward for MQTT protocol
### END INIT INFO

#
# Author:   Andreas Olsson &lt;andreas@arrakis.se&gt;
# Version:  @(#)autossh_tunnel.foo  0.1  27-Aug-2008  andreas@arrakis.se
# modified :    13-Feb-2015 mqtt.and@gmail.com 
#            
#           
# For each tunnel; make a uniquely named copy of this template.

## SETTINGS
#
# specify a host name in ~/.ssh/config,
# and also the ssh-key for connection must be located in ~/.ssh/
TUNNEL="Broker"
# You must use the real autossh binary, not a wrapper.
DAEMON=/usr/lib/autossh/autossh
#
## END SETTINGS

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

NAME=`basename $0`
# NAME is always including the extension of $0
# the script should be named without extension for good looking
PIDFILE=/var/run/${NAME}.pid
SCRIPTNAME=/etc/init.d/${NAME}
DESC="SSH Tunnel for MQTT protocol"

# exit when test result = false
test -x $DAEMON || exit 0

export MQTT_PF_PIDFILE=${PIDFILE}
ASOPT="-M 0 -N -F /home/pfuser/.ssh/config "${TUNNEL}

#   Function that starts the daemon/service.
#
#  ssh command is not able to make a pid file with -f (force background) option.
#  To obtain pid file properly, put --background, --make-pidfile option on the start-stop-deamon command,
#    --background option is forcing ssh process started without -f option into background.

d_start() {
    start-stop-daemon --start --quiet --chuid pfuser:pfuser --user pfuser --background --pidfile $PIDFILE \
        --make-pidfile --exec $DAEMON -- $ASOPT
    if [ $? -gt 0 ]; then
        echo -n " not started (or already running)"
    else
        sleep 1
        start-stop-daemon --stop --quiet --pidfile $PIDFILE \
        --test --exec $DAEMON &gt; /dev/null || echo -n " not started"
    fi

}

#   Function that stops the daemon/service.
d_stop() {
    start-stop-daemon --stop --quiet --pidfile $PIDFILE \
        --exec $DAEMON \
        || echo -n " not running"
}


case "$1" in
  start)
    echo -n "Starting $DESC: $NAME"
    d_start
    echo "."
    ;;
  stop)
    echo -n "Stopping $DESC: $NAME"
    d_stop
    echo "."
    ;;

  restart)
    echo -n "Restarting $DESC: $NAME"
    d_stop
    sleep 1
    d_start
    echo "."
    ;;
  *)
    echo "Usage: $SCRIPTNAME {start|stop|restart}" &gt;&amp;2
    exit 3
    ;;
esac

exit 0
</code></pre>

<p>ファイルができたら、実行できるようにパーミッションを設定します。</p>

<p>このスクリプトではautosshを起動しています。ssh をラップするコマンドで、sshを監視して、止まったら再起動するという事をしてくれます。基本的にsshコマンドが先のテストの時に動けば、問題なくautosshも起動できるはずです。</p>

<p>最初のコメント欄では、このスクリプトの起動の順番を指定しています。</p>

<ul>
<li><code># Provides:          mqtt-pf</code>

<ul>
<li>このスクリプトの名前です</li>
</ul>
</li>
<li><code># Required-Start:    $syslog $network $all</code>

<ul>
<li>このスクリプトを起動するときに必要な環境（バーチャルファシリティ）を指定</li>
</ul>
</li>
</ul>


<p>この指定がまたまた曲者で、うまく指定しないと起動してくれません。今回は色々試行錯誤して$allというファシリティを指定しました。すべての起動するべきスクリプトが実行されたあとに実行されるようになります。</p>

<p>$networkだけだと、dhcpが実行される前に実行されたりしてうまく行きませんでした。</p>

<p>実際にデーモンを起動するコマンド(start-stop-daemon)は以下のような設定になっています。</p>

<ul>
<li>&ndash;chuid pfuser:pfuser

<ul>
<li>ユーザ、グループIDを&#8217;pfuser、pfuser&#8217;で起動する</li>
</ul>
</li>
<li>&ndash;user pfuser

<ul>
<li>プロセスチェックするときのプロセスのユーザ指定(pfuserを指定）</li>
</ul>
</li>
<li>&ndash;background

<ul>
<li>バックグラウンドに移行</li>
</ul>
</li>
<li>&ndash;pidfile $PIDFILE

<ul>
<li>PIDを記録するファイルを指定</li>
</ul>
</li>
<li>&ndash;make-pidfile

<ul>
<li>PID ファイルを作るように指定</li>
</ul>
</li>
<li>&ndash;exec $DAEMON &ndash; $ASOPT

<ul>
<li>デーモンとして起動するコマンドとそれに渡すためのオプション</li>
</ul>
</li>
</ul>


<p>通常は&ndash;make-pidfileと&ndash;backgroundは不要のようですが、一応つけてあります。
コメントにもあるように、一部のコマンドはバックグラウンドに移行できないものがあり、それを強制するための&ndash;background オプションです。さらにこのオプションを指定した時にpidファイルが作られないことがあるそうなので、その対策として明示的にpidファイルをつるくように指定していています。</p>

<p>autosshコマンドに渡しているオプションは以下のとおりです。</p>

<ul>
<li>-M 0

<ul>
<li>接続が確立しているかどうかのチェックをするためのポート番号を指定</li>
<li>0はポートを使った接続チェックをしないで、sshコマンドが停止した時のみ再起動するという指定です。</li>
</ul>
</li>
<li>-N

<ul>
<li>これ以降のオプションはsshにそのまま渡されます。</li>
<li>N　は接続先のコマンドを起動しない指定です。</li>
</ul>
</li>
<li>-F /home/pfuser/.ssh/config

<ul>
<li>設定ファイルの指定です。ユーザを指定しているので不要かもしれません。</li>
</ul>
</li>
</ul>


<p>ここまでできたら、単体でこのスクリプトを動かしてみます。</p>

<pre><code class="sh">$ sudo /etc/init.d/mqtt-pf start
Starting SSH Tunnel for MQTT protocol: mqtt-pf.
</code></pre>

<p>と出てくれば成功です。</p>

<p><code>...not started.</code></p>

<p>となると失敗です。設定を見なおしてください。特にコメントで指定しているファシリティがきちんとしているか、pidができているか。など。<br/>
一応、このスクリプトは動作確認していますので、動くと思いますけど。。。。</p>

<h2>rc.dに登録</h2>

<p>ここまで行けば、だいたい大丈夫だとおもいます。</p>

<p>起動スクリプトの一部として、このポートフォワード設定を登録します。</p>

<pre><code class="sh">$ sudo update-rc.d mqtt-pf defaults
# として、登録

$ ls /etc/rc2.d
#　とすると、どの順番で起動することになるかがわかります。
#  S04mqtt-pfというファイル名になっていれば大丈夫かとおもいます。
</code></pre>

<p>rc2.dのディレクトリにあるスクリプト（へのリンク）はランレベル２の時に起動/停止するデーモンのための起動/停止スクリプトです。</p>

<p>Sで始まるスクリプトが起動用、Kで始まるスクリプトが停止用、番号が順番です。小さい方から順に実行されていきます。$allというファシリティを指定したので主要なスクリプトはすべて実行（起動）されたあとに起動されるようになっていて、大きめの番号が付いているはずです。</p>

<p>ここまでくれば、あとはリブートするだけです。</p>

<pre><code class="sh">$ sudo reboot
</code></pre>

<p>起動メッセージに</p>

<p><code>Starting SSH Tunnel for MQTT protocol: mqtt-pf. </code></p>

<p>と出てくれば成功です。多分。
ログインして、psで確認してみてください。</p>

<p>ずっとうまく行ってて、再起動だけうまく行かないという時は、パーミッションや設定ファイルの指定がうまく行っていない場合が多いです。</p>

<p>起動時はすべてrootで実行されますので、ユーザとして実行している状態とはちょっと違っています。そこら辺を気にかけながらデバグすると効率がいいかと思います。</p>

<p>以上！</p>

<p>ここまでたどり着くのに丸３日以上の時間がかかりました。。。。ユーザで実行してうまく起動するけれど、起動スクリプトに登録するとうまく動かない、というところで約２日を消費。あ〜、やっとできた。</p>

<p>ポイントは「rootユーザが実行する」という点と「接続先からなにか聞かれる場合がある」という点です。</p>

<p>おかげで、起動スクリプトは結構詳しくなりました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[autossh]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/12/autossh/"/>
    <updated>2015-01-12T08:53:44+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/12/autossh</id>
    <content type="html"><![CDATA[<p>sshのコネクションはどうしても切れてしまうことがあるので、それを阻止するためにautosshを使ってみました。<br/>
まず、sshのコマンドラインを簡素にするため、MQTTブローカへの接続設定を書いたconfigファイルを用意します。</p>

<!-- more -->


<p>sshのコンフィギュレーション</p>

<p>まずは、sshの接続のコマンドラインを簡略化するためにconfigファイルを設定します。<br/>
設定を隠蔽できる（シェルスクリプトなどにパラメタを書かなくてもいい）というてんで良いかなと思います。</p>

<p>&#8220;`sh ~/.ssh/config
Host Broker
    HostName        MQTT_Broker
    IdentityFile    ~/.ssh/id_rsa_MQTTClient
    User            MQTT_connection
    LocalForward    22883 localhost:1883
    Port            22222</p>

<pre><code>
ポート番号などは適宜設定してください。

こうすることで、`ssh -f -N Broker`のコマンドでトンネリング設定ができます。
ここで、公開鍵はパスフレーズ無しで作ったものを指定します。セキュリティのため、ブローカのssh設定にはポート制限やIP制限、コマンドを実行しないなどの処置を__必ず__とる必要があります。[設定の具体例](http://mm011106.github.io/blog/2015/01/11/secure-connection/)（「パスフレーズなしでの接続方法とセキュリティ設定」）

さらに、これが切れたとき自動的に再接続するため、autosshを導入します。
</code></pre>

<p> $ sudo apt-get install autossh
&#8220;`</p>

<p>autosshを使ってトンネリングを設定するには
<code>sh
 $ autossh -M0 -f -N Broker
</code></p>

<p>とします。</p>

<p>-M0 : 接続が切れているかどうかを確認するためのポート指定です。0は切断確認をポートではしないようにする設定です。</p>

<p>-f : 実行をバックグラウンドに移行します。</p>

<p>-N : sshへのオプションです。</p>

<p>autosshはsshを起動してそのプロセスを監視するプロセスを起動するコマンドです。</p>

<p>-Mオプションについては以下のように<a href="http://linux.die.net/man/1/autossh">解説</a>があります。</p>

<blockquote><p>specifies the base monitoring port to use. Without the echo port, this port and the port immediately above it ( port + 1) should be something nothing else is using. autossh will send test data on the base monitoring port, and receive it back on the port above. For example, if you specify &ldquo;-M 20000&rdquo;, autossh will set up forwards so that it can send data on port 20000 and receive it back on 20001.</p>

<p>Alternatively, a port for a remote echo service may be specified. This should be port 7 if you wish to use the standard inetd echo service. When an echo port is specified, only the specified monitor port is used, and it carries the monitor message in both directions.</p>

<p>Many people disable the echo service, or even disable inetd, so check that this service is available on the remote machine. Some operating systems allow one to specify that the service only listen on the localhost (loopback interface), which would suffice for this use.</p>

<p>The echo service may also be something more complicated: perhaps a daemon that monitors a group of ssh tunnels.</p>

<p>Setting the monitor port to 0 turns the monitoring function off, and autossh will only restart ssh upon ssh&rsquo;s exit. For example, if you are using a recent version of OpenSSH, you may wish to explore using the ServerAliveInterval and ServerAliveCountMax options to have the SSH client exit if it finds itself no longer connected to the server. In many ways this may be a better solution than the monitoring port.</p></blockquote>

<p>ということなので、0を指定するとsshがexitした時に再起動します。接続はServerAliveIntervalとServerAliveCountMaxだけ待って応答が来なければexitするので、その場合sshが再起動されるという事でしょう。「この方法がポートモニタするより良い方法だ」といっているので、そうすることにします。</p>

<p>sshのデフォルト<a href="http://www.unixuser.org/~euske/doc/openssh/jman/ssh_config.html">設定</a>では<code>ServerAliveInterval</code>は0になっている(確認のメッセージを送らない）ようなので、適宜設定する必要があります。<br/>
これがまたちょっと厄介ですね。あまり頻繁にパケットを送ると電話回線などプレミアムな回線を使っているときにコストがかさみます。本来はきちんとTPOで設定する必要があると思いますが、とりあえず30秒ぐらいに設定しておきます。</p>

<pre><code class="sh configに追記">#  connection alive detecting. 30 x 3 [s]
#
ServerAliveInterval 30
ServerAliveCountMax 3
</code></pre>

<p><code>ServerAliveCountMax</code>は3がデフォルトのようですので、応答がなくなったあと1分30秒で切断されるようになります。</p>

<p>これで、ちゃんと接続できるか確認してみます。</p>

<pre><code class="sh">$ ps ax | grep 'ssh'
 6543 ?        Ss     0:00 /usr/lib/autossh/autossh -M0 -N Broker
 6544 ?        S      0:00 /usr/bin/ssh -N Broker

$ mosquitto_sub -v -p 22883 -t '$SYS/#'
$SYS/broker/version mosquitto version 1.3.5
$SYS/broker/timestamp 2014-10-18 21:06:44+0100
 :
 :
</code></pre>

<p>Okですね。
さらに、keepalive確認のパケットがどのように出ているか確認してみます。</p>

<p>IPアドレスは下記のようになっています。<br/>
192.168.0.XXX クライアント<br/>
192.168.0.YYY サーバ</p>

<pre><code class="sh Keep Alive packets example">No.     Time        Source                Destination           Protocol Length Info
      1 0.000000    192.168.0.XXX         192.168.0.YYY           TCP      130    41387 &gt; SSHPORT　 [PSH, ACK] 
      2 0.010903    192.168.0.YYY         192.168.0.XXX           TCP      98     SSHPORT &gt; 41387 [PSH, ACK] 
      3 0.010941    192.168.0.XXX         192.168.0.YYY           TCP      66     41387 &gt; SSHPORT [ACK] 
      4 30.039772   192.168.0.XXX         192.168.0.YYY           TCP      130    41387 &gt; SSHPORT [PSH, ACK]
      5 30.043964   192.168.0.YYY         192.168.0.XXX           TCP      98     SSHPORT &gt; 41387 [PSH, ACK]
      6 30.044004   192.168.0.XXX         192.168.0.YYY           TCP      66     41387 &gt; SSHPORT [ACK]
</code></pre>

<p>30秒ごとに何かしらのパケットをやり取りしていることがわかりました。設定通りです。</p>

<p>さらに、途中で回線を切断してみます。</p>

<pre><code class="sh Packet example (in case of disconnection)">No.     Time        Source                Destination           Protocol Length Info
#　正常なalive確認のパケットやり取り
      1 0.000000    192.168.0.XXX         192.168.0.YYY         TCP      130    41405 &gt; SSHPORT [PSH, ACK]
      2 0.002137    192.168.0.YYY         192.168.0.XXX         TCP      66     SSHPORT &gt; 41405 [ACK]
      3 0.002566    192.168.0.YYY         192.168.0.XXX         TCP      98     SSHPORT &gt; 41405 [PSH, ACK]  
      4 0.041204    192.168.0.XXX         192.168.0.YYY         TCP      66     41405 &gt; SSHPORT [ACK] 

#　ここで回線を切断　sshがシャットダウンするまで130秒ぐらい待ち、回線を復旧させる
#
#  sshがautosshによって再起動されて通信を開始

# 切断前のコネクションをリセット
      5 138.686269  192.168.0.XXX         192.168.0.YYY         TCP      258    41405 &gt; SSHPORT [FIN, PSH, ACK]
      6 138.687686  192.168.0.YYY         192.168.0.XXX         TCP      98     SSHPORT &gt; 41405 [PSH, ACK] 
      7 138.687721  192.168.0.XXX         192.168.0.YYY         TCP      54     41405 &gt; SSHPORT [RST] 
      8 138.689209  192.168.0.YYY         192.168.0.XXX         TCP      130    SSHPORT &gt; 41405 [FIN, PSH, ACK] 
      9 138.689233  192.168.0.XXX         192.168.0.YYY         TCP      54     41405 &gt; SSHPORT [RST] 

#　新たなコネクションのスタート
     10 148.955582  192.168.0.XXX         192.168.0.YYY         TCP      74     41407 &gt; SSHPORT [SYN]
     11 148.958766  192.168.0.YYY         192.168.0.XXX         TCP      74     SSHPORT &gt; 41407 [SYN, ACK] 
</code></pre>

<p>という感じになりました。何回か試して見ましたが、切断前のコネクションをリセットするやり取りがない場合が多いかもしれません。さらに、alive確認のパケットは2往復でなく1往復半という事もありました。</p>

<p>無事sshの再起動も確認出来ました。</p>

<p>接続確認のためのパケットのサイズは、今回の実験では360byteぐらいでした。もしこの設定（30秒に1回）だとすると1日で1Mbyteぐらいの通信量です。
最近の安いデータ通信用のSIMにとってみれば大したデータ量ではないかもしれませんね。</p>
]]></content>
  </entry>
  
</feed>
