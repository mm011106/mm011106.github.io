<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: webcam, | MQTT and ...]]></title>
  <link href="http://mm011106.github.io/blog/categories/webcam/atom.xml" rel="self"/>
  <link href="http://mm011106.github.io/"/>
  <updated>2015-11-18T21:10:57+09:00</updated>
  <id>http://mm011106.github.io/</id>
  <author>
    <name><![CDATA[Masakazu Miyamoto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Paho mqttでリモートカメラ]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/08/remote-stillcam/"/>
    <updated>2015-02-08T09:49:46+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/08/remote-stillcam</id>
    <content type="html"><![CDATA[<p>Paho MQTTでリモートでシャッターを切れるカメラを作ってみました。撮った写真もMQTTで送られてきます。</p>

<blockquote><p>2015/2/28 UPDATE!!</p></blockquote>

<!-- more -->


<h2>カメラ側の設定</h2>

<p>まずは、デバイス（カメラ）側のスクリプト</p>

<p>ハードウエアとして、Raspberry Pi B+に専用のカメラモジュールをつけています。</p>

<pre><code class="python remotecam.py ">#!/usr/bin/env python
#
#

import paho.mqtt.client as mqtt
import os

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, rc):
    print("Connected with result code "+str(rc))
  # Subscribing in on_connect() means that if we lose the connection and
  # reconnect then subscriptions will be renewed.
    client.subscribe("my/device/stillcam/command")

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    cmd = str(msg.payload)
    print(msg.topic+" "+str(msg.payload))
    if cmd == "shoot":
        print "Say cheeees!"

        dummy = os.system("raspistill -w 1024 -h 768 -t 10 -o /run/shm/temp.jpg")
        dummy = os.system("mosquitto_pub -h my.broker.jp -t my/device/stillcam -f /run/shm/temp.jpg")

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect("my.broker.jp", 1883, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()
</code></pre>

<p>パブリッシュ設定したメッセージが来ると、on_messageがコールされます。<br/>
メッセージが&#8221;shoot&#8221;だったら、osコマンド&#8221;raspistill&#8221;を実行して写真を撮ります。<br/>
さらにそのデータをosコマンド&#8221;mosquitto_pub&#8221;でパブリッシュします。</p>

<p>ちょっと格好悪いですけど、MQTTで写真データを送るのにmosquittoを使っています。<del>ざっくり試した感じですと、paho-mqttではバイナリのペイロードをうまくハンドリングできないようで、多分なんか設定があるのだと思います。探してみます。</del></p>

<h4>2015/2/11追記：</h4>

<h4>上記のバイナリデータのハンドリングの件ですが、うまく行かない理由は私のスキル不足です。多分python内部での変数のデータ扱いをうまく変換してやる必要が有りそうです。  只今勉強中。</h4>

<blockquote><h3>2015/2/28  追記：</h3>

<p>上記、バイナリデータの送信の件ですが、<br/>
実際に出てくるエラーは<br/>
<code>UnicodeDecodeError: 'ascii' codec can't decode</code><br/>
というものでしたので、そのまま検索をかけてみると、デコードがうまく行っていない、旨のエラーのようです。<br/>
であれば、変換をしないように設定すればいいのかなあ、どうするのかなあ、と思いつつソースコードを（わからないなりに）眺めていると、</p></blockquote>

<pre><code class="sh http://git.eclipse.org/c/paho/org.eclipse.paho.mqtt.python.git/tree/src/paho/mqtt/client.py">            if isinstance(payload, str):
                upayload = payload.encode('utf-8')
                payloadlen = len(upayload)
            elif isinstance(payload, bytearray):
                payloadlen = len(payload)
            elif isinstance(payload, unicode):
                upayload = payload.encode('utf-8')
                payloadlen = len(upayload)
</code></pre>

<blockquote><p>という記述を見つけ、payloadのタイプによってエンコードを分けていることがわかりました。<code>bytearray</code>なら何もせずにそのままのデータが送られるので<code>bytearray</code>にすればいい。 <br/>
再び検索して、読み込んだファイルをbytearray型で変数に代入する方法を調べ、結果として次のようなソースコードになりました。</p></blockquote>

<pre><code class="sh replace with 'mosquitto_pub ......'"># 撮影した写真ファイルは/run/shm/temp.jpg
       with open('/run/shm/temp.jpg', 'rb') as source:
            payload_pub = bytearray(source.read())

# bytearray 型にして変数に代入、それをそのままペイロードとしてパブリッシュ
        client.publish(topic_root+topic_pub, payload_pub)
</code></pre>

<blockquote><p>これで無事バイナリファイルを送信することが出来ました。</p></blockquote>

<p>USBのカメラを使う場合はraspistillのコマンドを適宜変更すればいいかと思います。</p>

<p>このスクリプトを実行可能に設定して、実行させます。これで待ち受け状態。</p>

<h2>コントローラ側</h2>

<p>別のPCでは、</p>

<ul>
<li>シャッターを切るコマンドを発行する</li>
<li>送られてきた写真のデータを保管する</li>
</ul>


<p>という作業があります。</p>

<p>まずは、送られてきたデータを保管するスクリプトを作ります。</p>

<pre><code class="python photo_sub.py">#!/usr/bin/env python
#
#
#

import paho.mqtt.client as mqtt
import datetime

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, rc):
    print("Connected with result code "+str(rc))
  # Subscribing in on_connect() means that if we lose the connection and
  # reconnect then subscriptions will be renewed.
    client.subscribe("my/device/stillcam")

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):

    # print(msg.topic+" "+str(msg.payload))
    filename = "./image/" + datetime.datetime.today().strftime("%H%M%S%f") + ".jpg"
    outfile=open( filename , 'w')
    outfile.write(msg.payload)
    print "subscribe: " + filename
    outfile.close

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect("my.broker.jp", 1883, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()
</code></pre>

<p>このスクリプトでは、my/device/stillcamというトピックにパブリッシュされたデータを取り込んでファイル名（タイムスタンプ）をつけて保存します。</p>

<p>このスクリプトを実行して、データを待ち受けます。</p>

<p>最後にシャッタを切るコマンドを送ります。<br/>
とりあえずは、コマンドラインからです。</p>

<pre><code class="sh ">$ mosquitto_pub -h my.broker.jp -t my/device/stillcam/command -m "shoot"
</code></pre>

<p>これで、メッセージ&#8221;shoot&#8221;をトリガにして、写真を撮影し、それを転送して保存するまでの一連の作業が行われます。</p>

<p>デバイス側の処理負荷を確認するため1秒に1回シャッターを切る動作を続けて見ました。
結果的には、カメラと転送の処理で数%程度の負荷のようです。<br/>
ちなみにこのカメラ、この設定では1秒間隔以上のスピードで連続して撮影することはできませんでした。</p>

<p>カメラがRaspi用のモジュールですので、かなりオーバーヘッドが小さい感じもします。
CPU的には処理が軽くていいのですが、ハードウエア的には取り回しが悪く、ちょっといまいちな感じもします。<br/>
応用のシーンによりますが、今回私が想定しているケースでは使いにくいです。</p>

<p>あとで、USBcamでやってみようと思います。</p>
]]></content>
  </entry>
  
</feed>
