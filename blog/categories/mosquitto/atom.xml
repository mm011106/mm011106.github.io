<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mosquitto | MQTT and ...]]></title>
  <link href="http://mm011106.github.io/blog/categories/mosquitto/atom.xml" rel="self"/>
  <link href="http://mm011106.github.io/"/>
  <updated>2015-01-12T11:12:55+09:00</updated>
  <id>http://mm011106.github.io/</id>
  <author>
    <name><![CDATA[Masakazu Miyamoto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[接続の暗号化]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/11/secure-connection/"/>
    <updated>2015-01-11T11:05:38+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/11/secure-connection</id>
    <content type="html"><![CDATA[<p>普通にMQTTを応用しようとすると、避けては通れない暗号化です。あまり素人が手出しするべき所ではないかもしれませんが、勉強のため考えて見ました。</p>

<!-- more -->


<p>mosquitto.confを眺めてみると、mosquittoでは2つのやり方が準備されているようです。</p>

<ul>
<li>公開鍵認証・暗号化</li>
</ul>


<p>公開鍵をお互いにやり取りして、お互いを認証・暗号化する普通のやり方ですね。</p>

<ul>
<li>証明書ベース認証・暗号化</li>
</ul>


<p>HTTPで一般的に使われている証明書による認証ですね。https で始まるwebサイトでは暗号化されるように、この仕組みを使えばMQTTでも通信が暗号化されます。<br/>
サーバーがオープンで誰でもが接続できるような状況にするためには、必須です。</p>

<p>mosquittoではユーザ（サブスクライバ、パブリッシャ）認証のためにユーザ名、パスワード方式が使えますが、認証時に平文でこれらがやり取りされるという事ですので、通信経路そのものの暗号化が欠かせません。</p>

<p>MQTTブローカに頼らない暗号化という意味では ssh しかないでしょうか。
ブローカがオープンでない場合であれば、ポートフォワードと合わせ技で安全性が高められるかもしれません。
ただ、この場合、ネットワーク環境によってはsshのトンネリングができない（ポリシー的に）という場合もあるかと思うので、環境の調査が必要かと思います。</p>

<p>最近は<a href="http://jpmens.net/2014/07/03/the-mosquitto-mqtt-broker-gets-websockets-support/">websocket</a>という接続方法もあるので、MQTTブローカをweb applicationでラップしてセキュアにするというやり方もあるかもしれません。</p>

<p>今回はsshのポートフォワードで暗号化してみましたので報告です。</p>

<p>まず、何はなくとも検索。ssh mosquittoあたりでgoogleさんに聞いてみたところ、<a href="http://diabolicalws.blogspot.jp/2012/02/tunneling-mqtt-over-ssh.html">この</a>のサイトがヒット。正しくやろうとしていたことです。</p>

<hr />

<p>このページの最終目標としては、簡易的なVPNとしてのsshによるトンネリングを使ってMQTTプロトコルをセキュアにしようという事のようです。
手順としては、</p>

<ol>
<li><p>トンネリングの設定</p></li>
<li><p>トンネルを使った通信の設定</p></li>
<li><p>パスフレーズなしでの接続方法とセキュリティ設定</p></li>
</ol>


<p>順を追ってやってみます。</p>

<h3>トンネリグの設定</h3>

<p>まずクライアント側の設定です。</p>

<pre><code class="sh">ssh -f -L 22883:127.0.0.1:1883 SSHusername@MQTT -N  
</code></pre>

<p>とすることで、クライアント側のポート22883 に対する通信が暗号化された上でサーバ&#8221;MQTT&#8221;の1883に接続されます。ユーザ名は&#8221;SSHusername&#8221;です。
各オプションの意味は以下のとおりです。</p>

<p> -f : バックグラウンドで動作</p>

<p> -L : ローカル側でのポートフォワード（クライアント側のポート変換が設定されます）</p>

<p> -N : サーバ側でコマンドを実行しないように指定</p>

<p>この例ではポートは標準の22となっています。必要に応じて-pオプションでssh通信そのもののポート番号を指定してください。 sshのポート番号も専用のものにしておくことで、更にセキュリティを確保できるかもしれません。<br/>
ここらへんはsshのポートフォワード設定を参照してもらったほうが正しい理解が得られるかと。</p>

<p>この接続をするためには、クライアント、サーバ共にsshが動く環境であることが必要です。適宜設定してください。</p>

<p>このコマンドを実行するとパスフレーズを聞かれるはずです。実際の無人運用ではこれが問題になりますが、これは後ほど解決してもらえます。</p>

<h3>トンネルを使った通信の設定</h3>

<p>上記の操作でセキュアな通信経路が22883ポートに設定されましたので、これを使って実際にMQTTプロトコルのデータを流してみます。</p>

<pre><code class="sh">mosquitto_sub -h 127.0.0.1 -p 22883 -u dan -P password -t 'test/#'
</code></pre>

<p>-P, -uでユーザ名とパスワードを指定してブローカにサブスクライバとしてログインしています。ホストはローカルホスト、ポートは先程トンネルを設定した22883に指定します。<br/>
-P, -uは必須ではないです。私はこれらナシでつかってます。</p>

<p>トピックを適切に設定してあれば、なにかメッセージを受け取れるはずです。</p>

<h3>パスフレーズなしでの接続方法とセキュリティ設定</h3>

<p>参考にしたページでは、&#8221;Key-Based authentification&#8221;と説明されていますが、公開キーを事前にやり取りしている間柄なら、十分信用できるだろうという事で、鍵を持っている相手はパスフレーズなしでログインさせましょう、という設定です。<br/>
この設定では、ssh接続に際しパスフレーズなしで接続できるようになってしまうので、鍵を他の用途で使うとセキュリティに問題が出る可能性があります。そのため、「このトンネリングだけに使う専用の鍵を用意するように」と注意書きがあります。</p>

<p>パスフレーズ無しでキーを作り、それをサーバに登録します。</p>

<pre><code class="sh">ssh-keygen
ssh-copy-id SSHusername@MQTT
</code></pre>

<p>サーバ側のセキュリティ確保のため、クライアントのキー記述の最初の部分に以下のような設定を追記します。</p>

<pre><code class="sh">from="192.168.1.*",no-pty,permitopen="127.0.0.1:1883",command="/bin/false" ssh-rsa........
</code></pre>

<p>この例では</p>

<ul>
<li>接続先のIP制限 from=</li>
<li>ターミナルのアサインをしない no-pty</li>
<li>ローカルホストの指定ポートのみオープン可能にする permitopen=</li>
<li>ログイン時に実行するコマンドを /bin/falseに設定</li>
</ul>


<p>ということを指定しています。
具体的には、192.168.1.*のネットワークからの接続に限定、ターミナルをアサインしない、ローカルホストの1883への接続のみを許可する、リモートから接続するときに指定されたコマンドを実行しない。
という事になりそうです。<br/>
くわしくは、<a href="http://www.nxmnpg.com/ja/8/sshd#9">ここらへん</a>を参照してください。</p>

<p>私の実験では、IPアドレスの制限をしない設定、で実行してうまく動いています。</p>

<p>本来的には、証明書ベースの認証システムを組むのがいいのでしょうけれど、証明書の発行など、よくわかっていないと事故に繋がりそうなので、今回は初学者向けということでトンネリングを実験して見ました。<br/>
小規模なシステムでネットワーク環境もある程度わかっているところにデバイスを配置するには十分な感じかと思います。</p>

<p>また、MQTTプロトコル上からデバイスがつながっているシステムの操作をするときに、重要なパラメタの制御は1箇所でできないようにするとか、あるデバイスの許可とペアで設定して初めてアクチュエートするなど、システム上でのセキュリティ構築も必要かもしれません。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2つのトピックが。。。]]></title>
    <link href="http://mm011106.github.io/blog/2014/12/19/disable-clean-session/"/>
    <updated>2014-12-19T20:45:30+09:00</updated>
    <id>http://mm011106.github.io/blog/2014/12/19/disable-clean-session</id>
    <content type="html"><![CDATA[<p>現在、テスト用に2台のRaspiでMQTTを使ったテレメトリシステムを運用しています。先日、どうも一台のRaspiのファイルシステムの調子が悪くなったようで、コンソールにエラーが出ていました。立ち上がらなくなると大変なので、適宜バックアップを取り、もう一つ新しいRaspiを用意して移行する手順を進めていました。</p>

<!-- more -->


<p>そして、テストとして新しいRaspiからのデータを手元の計算機（Ubuntu)でサブスクライブしてみたところ、新しいRaspiからのトピックだけを受信しているはず（と思っている）なのに、古いサブスクライブのトピックも同時に受信されてしまいます。</p>

<p>よく見てみると、古いRaspiからのデータをサブスクライブする時にオ、プションとして<code>--disable-clean-session</code>と<code>--id</code>を指定していました。新しいRaspiには、同じオプション（idも同じ）で違うトピック（新しいRaspiがパブリッシュするトピック）をサブスクライブするようにブローカにお願いしています。</p>

<p>ここでハタと気づいたのが、「もしかしたら、同じIDだし、クリーンセッションをオフにしてサブスクライブ要求しているから、一度サブスクライブかけたトピック（セッション）はクリーンにならず、他のトピックをサブスクライブしてもついてくるのでは・・・」という点でした。</p>

<p>これを確認するため、<code>--disable-clean-session</code>をとって、ほかのパラメタは同じで、古いRaspiがパブリッシュしているトピックをサブスクライブ要求してすぐに切断し（これで、セッションが切れるはず）、さらに新しいRaspiがパブリッシュしているトピックのみをサブスクライブ要求してみました。これで昔のトピックサブスライブセッションはクリアされ、新しいトピックのみが受信されることになるはずです。</p>

<p>結果、新しいサブスクライブだけを入手することが出来ました。</p>

<p>具体的には、</p>

<pre><code class="sh Why Two topics comes up??">$ mosquitto_sub --disable-clean-session --id abcd -t data/OLD_pi -q 1
(古いRaspiからのデータ）
^c
　　これで、このサブスクライブはおしまいにした、と思っていたが。。。。

$ mosquitto_sub --disable-clean-session --id abcd -t data/NEW_pi -q 1
（古いRaspiからのデータ）
（新しいRaspiからのデータ）
^C

　　？？なぜ2つから？？
    --disable-clean-sessionがあると一度サブスクライブしたセッションは、
    IDに張り付いているのでは？？？
    だから、同じIDで違うトピックをサブスクライブしようとしても、
    前のセッションも復活する？
    ならば、昔のセッションをクリアにしてあげればいいはず。

$ mosquitto_sub --id abcd -t data/OLD_pi -q 1
^c
    clean sessionで接続してすぐに切断。
    これで、古いサブスクライブのセッションが切れたはず。

$ mosquitto_sub --disable-clean-session --id abcd -t data/NEW_pi -q 1
（新しいRaspiからのデータ）
（新しいRaspiからのデータ）
（新しいRaspiからのデータ）

　　思ったとおり
</code></pre>

<p>という感じです。</p>

<p>ということで、スクリプトで Clean Session を設定していないサブスクライブを切り替えるときは、プロセスをkillするだけではだめで、 Clean Sessionで一度接続して切断することで、セッションを切る必要があるという事でした。さもないと、同じIDで再接続した時に前にサブスクライブしていたトピックも送られてきてしまう、のでは？ということした。</p>
]]></content>
  </entry>
  
</feed>
