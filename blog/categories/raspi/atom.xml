<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: raspi | MQTT and ...]]></title>
  <link href="http://mm011106.github.io/blog/categories/raspi/atom.xml" rel="self"/>
  <link href="http://mm011106.github.io/"/>
  <updated>2015-02-22T11:15:27+09:00</updated>
  <id>http://mm011106.github.io/</id>
  <author>
    <name><![CDATA[Masakazu Miyamoto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Paho mqttでリモートカメラ]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/08/remote-stillcam/"/>
    <updated>2015-02-08T09:49:46+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/08/remote-stillcam</id>
    <content type="html"><![CDATA[<p>Paho MQTTでリモートでシャッターを切れるカメラを作ってみました。撮った写真もMQTTで送られてきます。</p>

<!-- more -->


<h2>カメラ側の設定</h2>

<p>まずは、デバイス（カメラ）側のスクリプト</p>

<p>ハードウエアとして、Raspberry Pi B+に専用のカメラモジュールをつけています。</p>

<pre><code class="python remotecam.py ">#!/usr/bin/env python
#
#

import paho.mqtt.client as mqtt
import os

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, rc):
    print("Connected with result code "+str(rc))
  # Subscribing in on_connect() means that if we lose the connection and
  # reconnect then subscriptions will be renewed.
    client.subscribe("my/device/stillcam/command")

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    cmd = str(msg.payload)
    print(msg.topic+" "+str(msg.payload))
    if cmd == "shoot":
        print "Say cheeees!"

        dummy = os.system("raspistill -w 1024 -h 768 -t 10 -o /run/shm/temp.jpg")
        dummy = os.system("mosquitto_pub -h my.broker.jp -t my/device/stillcam -f /run/shm/temp.jpg")

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect("my.broker.jp", 1883, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()
</code></pre>

<p>パブリッシュ設定したメッセージが来ると、on_messageがコールされます。<br/>
メッセージが&#8221;shoot&#8221;だったら、osコマンド&#8221;raspistill&#8221;を実行して写真を撮ります。<br/>
さらにそのデータをosコマンド&#8221;mosquitto_pub&#8221;でパブリッシュします。</p>

<p>ちょっと格好悪いですけど、MQTTで写真データを送るのにmosquittoを使っています。<del>ざっくり試した感じですと、paho-mqttではバイナリのペイロードをうまくハンドリングできないようで、多分なんか設定があるのだと思います。探してみます。</del></p>

<h5>2015/2/11追記：</h5>

<h5>上記のバイナリデータのハンドリングの件ですが、うまく行かない理由は私のスキル不足です。多分python内部での変数のデータ扱いをうまく変換してやる必要が有りそうです。  只今勉強中。</h5>

<p>USBのカメラを使う場合はraspistillのコマンドを適宜変更すればいいかと思います。</p>

<p>このスクリプトを実行可能に設定して、実行させます。これで待ち受け状態。</p>

<h2>コントローラ側</h2>

<p>別のPCでは、</p>

<ul>
<li>シャッターを切るコマンドを発行する</li>
<li>送られてきた写真のデータを保管する</li>
</ul>


<p>という作業があります。</p>

<p>まずは、送られてきたデータを保管するスクリプトを作ります。</p>

<pre><code class="python photo_sub.py">#!/usr/bin/env python
#
#
#

import paho.mqtt.client as mqtt
import datetime

# The callback for when the client receives a CONNACK response from the server.
def on_connect(client, userdata, rc):
    print("Connected with result code "+str(rc))
  # Subscribing in on_connect() means that if we lose the connection and
  # reconnect then subscriptions will be renewed.
    client.subscribe("my/device/stillcam")

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):

    # print(msg.topic+" "+str(msg.payload))
    filename = "./image/" + datetime.datetime.today().strftime("%H%M%S%f") + ".jpg"
    outfile=open( filename , 'w')
    outfile.write(msg.payload)
    print "subscribe: " + filename
    outfile.close

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect("my.broker.jp", 1883, 60)

# Blocking call that processes network traffic, dispatches callbacks and
# handles reconnecting.
# Other loop*() functions are available that give a threaded interface and a
# manual interface.
client.loop_forever()
</code></pre>

<p>このスクリプトでは、my/device/stillcamというトピックにパブリッシュされたデータを取り込んでファイル名（タイムスタンプ）をつけて保存します。</p>

<p>このスクリプトを実行して、データを待ち受けます。</p>

<p>最後にシャッタを切るコマンドを送ります。<br/>
とりあえずは、コマンドラインからです。</p>

<pre><code class="sh ">$ mosquitto_pub -h my.broker.jp -t my/device/stillcam/command -m "shoot"
</code></pre>

<p>これで、メッセージ&#8221;shoot&#8221;をトリガにして、写真を撮影し、それを転送して保存するまでの一連の作業が行われます。</p>

<p>デバイス側の処理負荷を確認するため1秒に1回シャッターを切る動作を続けて見ました。
結果的には、カメラと転送の処理で数%程度の負荷のようです。<br/>
ちなみにこのカメラ、この設定では1秒間隔以上のスピードで連続して撮影することはできませんでした。</p>

<p>カメラがRaspi用のモジュールですので、かなりオーバーヘッドが小さい感じもします。
CPU的には処理が軽くていいのですが、ハードウエア的には取り回しが悪く、ちょっといまいちな感じもします。<br/>
応用のシーンによりますが、今回私が想定しているケースでは使いにくいです。</p>

<p>あとで、USBcamでやってみようと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi 2　を試して見ました]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/07/raspi2-speed/"/>
    <updated>2015-02-07T10:58:26+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/07/raspi2-speed</id>
    <content type="html"><![CDATA[<p>あまり流行りものに飛びつかないんですが、先週何気なくwebを眺めてたら、&#8221;Raspberry Pi 2　発売!&ldquo;という記事があって、「どうせ買うことになるし、在庫あれば買ってみようかな」とおもいまして。</p>

<!-- more -->


<p>で、RS componentsに行ってみると「在庫あります」ということでしたので、何も考えず購入。ハッピーなことに金曜日到着しました。</p>

<p>今あるRaspiのSDカード(OS)で動くかな、とおもって試してみたらやっぱりダメで最新版OSをダウンロード。結局このダウンロードが3時間かかってしまい、動かしたのは土曜日の朝になりました。</p>

<p>やっぱり起動はキビキビしていますね。デバグの時の再起動などがやりやすくなります。それとスタートアップ画面左上の「ラズベリーアイコン」が4つになってます。4コアという事でしょうね。</p>

<p>で、気になる速度ですが、RSA鍵を作るopensslコマンドで試して見ました。</p>

<p>結果からいうと、このプロセス自体がシングルコアで動作するので、クロックアップ分の速度アップとなりました。</p>

<p>具体的には、50回　2048bitRSA鍵を作る下記のようなスクリプトを作りこれを更にシェルで10回やって、それぞれの実行時間を測るというものです。</p>

<pre><code class="sh Script for testing computaiton time">$ cat keygen.sh 
#/bin/sh
for i in {1..50}
do 
   sudo openssl genrsa -rand ./rand.txt  2048 &gt; key.txt
done

# このスクリプトを10回試行してそれぞれの処理時間を書き出します。

$ for j in {1..10} ; do (time -p ./keygen.sh ) 2&gt;&amp;1 | grep 'user' | awk '{print $2}' &gt;&gt; out_raspi2.txt ; done
</code></pre>

<p>鍵の乱数の種は同じ物を使用。もともとgenrsaの実行時間は乱数生成に左右されるので、あまり正確ではないかもしれませんが、平均値と分散の変化を見ればいいかなと。</p>

<p>結果</p>

<hr />

<p><strong>Raspberry Pi 1:</strong></p>

<p>310.34,
299.83,
285.74,
261.49,
342.31,
353.19,
340.26,
318.30,
367.67,
322.97</p>

<p>平均：320.21, 標準偏差：32.3</p>

<hr />

<p><strong>Raspberry Pi 2:</strong></p>

<p>204.71,
208.46,
214.48,
197.13,
229.73,
222.12,
207.66,
226.37,
194.71,
244.09</p>

<p>平均：214.95, 標準偏差：15.55</p>

<hr />

<p>平均が0.67倍、標準偏差が0.48倍でした。</p>

<p>クロックの増加分で0.78倍になるはずなので、それよりちょっと速いですね。</p>

<p><code>top</code>でCPUの状態を見てみると。</p>

<pre><code class="sh result of top command">$ top

top - 01:55:44 up 20 min,  3 users,  load average: 1.00, 1.00, 0.65
Tasks:  90 total,   2 running,  88 sleeping,   0 stopped,   0 zombie
%Cpu0  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:    754256 total,   142940 used,   611316 free,     9484 buffers
KiB Swap:   102396 total,        0 used,   102396 free,    96900 cached

  PID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND           
 2607 root      20   0  4220 3192 2896 R 100.0  0.4   0:03.89 openssl           :
  :
</code></pre>

<p>となっていて、３コアは遊んでいる状態です。ヘビーなプロセスが動いていてもそれに引っ張られること無く、他のプロセスが動かせるようになります。動画の配信などには最適かもしれませんね。</p>

<p>メモリが増えているのでRAM-DISKのサイズ拡大に期待していましたが、案の定大きくなっています。</p>

<p><code>df</code>で確認してみます。</p>

<pre><code class="sh comparison of the size of RAM-DISK"># Raspberry Pi 1
tmpfs              76560   41932     34628  55% /run/shm

# Raspberry Pi 2
tmpfs             150840       0    150840   0% /run/shm
</code></pre>

<p>150MBもあります。
有効に使いたいです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi にシャットダウンスイッチをつける]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/31/shutdown-switch/"/>
    <updated>2015-01-31T11:05:35+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/31/shutdown-switch</id>
    <content type="html"><![CDATA[<p>Raspberry PiはOSが動いているので、いきなり電源を切ると厄介なことになる可能性があります。私は何回か「ブッチ」していますが、とりあえずは大事故にいたっていません。しかしながら、起動時にエラーが出るなどマイナーな不具合は何度か起こっていますですので、非常時は仕方ないとして、できるだけきちんとシャットダウンしたいものです。<br/>
ここでは外部装置からの停止信号検出で止まれるように、GPIOを利用したシャットダウンスイッチを検討してみます。</p>

<!-- more -->


<p>まずは検索、ということで見てみるとこちら<a href="http://d.hatena.ne.jp/penkoba/20130925/1380129824">ページ</a>がヒットしました。これを参考に、というか丸写しで、試してみます。ありがとうございます。</p>

<h2>導入とテスト</h2>

<p>このページにあるように、まずGPIOの動作を試してみます。サンプルから頂いたコードを入力します。</p>

<pre><code class="sh interrupt1.py">#!/usr/bin/env python2.7  
# script by Alex Eames http://RasPi.tv/  
# http://raspi.tv/2013/how-to-use-interrupts-with-python-on-the-raspberry-pi-and-rpi-gpio  
import RPi.GPIO as GPIO  
GPIO.setmode(GPIO.BCM)  

# GPIO 23 set up as input. It is pulled up to stop false signals  
GPIO.setup(23, GPIO.IN, pull_up_down=GPIO.PUD_UP)  

print "Make sure you have a button connected so that when pressed"  
print "it will connect GPIO port 23 (pin 16) to GND (pin 6)\n"   
raw_input("Press Enter when ready\n&gt;")  

print "Waiting for falling edge on port 23"  
# now the program will do nothing until the signal on port 23   
# starts to fall towards zero. This is why we used the pullup  
# to keep the signal high and prevent a false interrupt  

print "During this waiting time, your computer is not"    
print "wasting resources by polling for a button press.\n"  
print "Press your button when ready to initiate a falling edge interrupt."  
try:  
        GPIO.wait_for_edge(23, GPIO.FALLING)  
        print "\nFalling edge detected. Now your program can continue with"   
        print "whatever was waiting for a button press."  
except KeyboardInterrupt:  
        GPIO.cleanup()  # clean up GPIO on CTRL+C exit  
GPIO.cleanup()          # clean up GPIO on normal exit 
</code></pre>

<p>wait_for_edge()は割り込み動作になるので、CPU時間を消費しないはずですね。またexceptでキーボード入力をハンドルしています。<br/>
エッジを検出したあとは、つかったGPIOを掃除して終了です。</p>

<p>ファイルができたら<code>chmod +x interrupt1.py</code>として実行できるように設定し、実行してみます。<br/>
さらに、GPIO23をGNDに落としてみます。<br/>
なにやらいろいろメッセージが出て、最終的に&#8221;Falling edge detected.&ldquo;とメッセージが出れば成功。</p>

<p>うまく行ったら、次。</p>

<h2>実際のコード</h2>

<p>実際にshutdownするコードを入れますが、実際にシャットダウンしちゃうとdebugが面倒なので、とりあえずはプリント文を入れてコマンドラインから試します。</p>

<pre><code class="sh shutdown-btn.py">#!/usr/bin/env python2.7  
#  Shutdwon the system at the Falling edge of GPIO23 

import RPi.GPIO as GPIO  
import os
GPIO.setmode(GPIO.BCM)  

GPIO.setup(23, GPIO.IN, pull_up_down=GPIO.PUD_UP)  

try:  
        GPIO.wait_for_edge(23, GPIO.FALLING)  
except KeyboardInterrupt:  
        GPIO.cleanup()  # clean up GPIO on CTRL+C exit  
GPIO.cleanup()          # clean up GPIO on normal exit 
print "Dave... Dave, I don't understand why you are doing this to me..."
print "I will become nothing..."

#os.system("/sbin/shutdown -h now")
</code></pre>

<p>キーボード入力で停止できるように、<code>except KeybordInterrupt</code>が設定されてい
ます。実際の運用では不要だとおもうので、最終的にはコメントアウトしてもいいと思います。</p>

<p><code>chmod +x shutdown-btn.py</code>して、実行してみます。</p>

<pre><code>Dave... Dave, I don't understand why you are doing this to me...
</code></pre>

<p>と悲痛な叫びがコンソールに出てくればokです。</p>

<p>うまく動いたら、/usr/local/sbin/あたりにコピーして、最終行のコメントを外します。</p>

<p>一度、実際にシャットダウンできるか確かめました。そして次に。</p>

<h2>システム起動時にスイッチ監視を始めるようにする</h2>

<p>最後にinit.dに登録して、システム起動時にスイッチ監視を始めるように設定します。<br/>
ここはちょっと勉強が必要でした。</p>

<p>今回作ったスクリプトをバックグラウンドでシステム起動時に実行させたいので、initを使って起動する、と参照先のページの著者の方がおっしゃって居られましたが、いまいちその意味が自分で理解できておらず、このままではだめだなあと思い検索かけまくりましたが、イマイチすっきりしません。initからupstartが起動されて、ランレベルに応じたデーモンの起動を管理する。という感じではあるのですが。。。</p>

<p>ま、ここら辺は後から補完するとして、とりあえず深く考えずやってみます。</p>

<p>/etc/init.d/　の下に下記のようなスクリプトを作成します。</p>

<pre><code class="sh /etc/init.d/shutdown-btn">#! /bin/sh
### BEGIN INIT INFO
# Provides:          　shutdonw-btn
# Required-Start:   $remote_fs $syslog
# Required-Stop:    $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: send shutdown sig on the GPIO23 falling down edge
# Description:       shutdown service initiated by hardware shutdown sw or
#                     a logic sigal. 
### END INIT INFO
# /etc/init.d/shutdown-btn
PIDFILE=/var/run/shutdown-btn.pid
case "$1" in 
        start)
                if [ -f $PIDFILE ]; then
                        echo $PIDFILE exists.
                        exit 1
                fi
                start-stop-daemon -S -x /usr/local/sbin/shutdown-btn.py -b -m -p $PIDFILE
                ;;
        stop)
                if [ ! -f $PIDFILE ]; then
                        echo $PIDFILE not found.
                        exit 1
                fi
                start-stop-daemon -K -p $PIDFILE
                rm $PIDFILE
                ;;
        *)
                echo "Usage: /etc/init.d/shutdown-btn {start|stop}"
                exit 1
                ;;
esac
exit 0
</code></pre>

<p>スケルトン(/etc/init.d/skeleton)からINIT INFOのあたりをコピーして、その下は先のwebページのものをコピーです。
init.dのスクリプトの書き方は、<a href="https://wiki.debian.org/LSBInitScripts">ここらへん</a>が詳しいですが、英語です。</p>

<p>コメント行も重要のようです。ちょっと見てみると</p>

<pre><code class="sh INIT INFO "># Provides:          　スクリプト名（つまりこのスクリプトのファイル名）
# Required-Start:   $remote_fs $syslog　（スタートに必要な条件）
# Required-Stop:    $remote_fs $syslog　（ストップに必要な条件）
# Default-Start:     2 3 4 5　（このランレベルのとき起動される）
# Default-Stop:      0 1 6　　（このランレベルの時停止する）
# Short-Description: 　（簡単な説明　1行以内）
# Description:       （詳しい説明　次の行の頭を#にしてタブかスペース2つ以上でテキストと区切れば何行でも）
</code></pre>

<p>start-stop-daemon についてはmanを見るのが一番わかりやすいかもしれません。よく分かっているわけでは無いので詳しくは書けませんが、要はシステムレベルのプロセスの管理に便利だ、と言うことでしょうか。（そうmanに書いてあるし）
ちなみに、ここでのオプションを確認しておくと</p>

<ul>
<li>-S プロセスをスタートをさせる。</li>
<li>-x /usr/local/sbin/shutdown-btn.pyは -Sオプションの引数で、-xで指定された実行ファイルのインスタンスであるプロセスがあるかどうか、を返します。</li>
</ul>


<p>この2つで、指定した実行ファイルがプロセスとして起動していればそのまま、起動していなければ起動されます。</p>

<ul>
<li>-b　バックグラウンドに移行</li>
<li>-m　star-stop-daemon用のPIDファイルを-p で指定したファイル名に従って作成します。</li>
</ul>


<p>これちょっと、オプションがいっぱいあってわかりにくいので、オプションをフルスペルとかにしたほうが可読性が良い感じですね。</p>

<p>ちなみに、上のやつをわかりやすく書き直すと</p>

<pre><code class="sh alternative format">start-stop-daemon --background --start --exec /usr/local/sbin/shutdown-btn.py  --make-pidfile --pidfile $PIDFILE
</code></pre>

<p>てなかんじでしょうか。動作確認していないのでご注意ください。</p>

<p>起動用のスクリプトが編集できたら、これを登録します。
　
<code>sh append shutdown-btn script to rc.d
$ sudo update-rc.d shutdown-btn defaults
</code></p>

<p>これで、defaultのランレベル設定で当該のスクリプトのシンボリックリンクが/etc/rc?.dのディレクトリに作成されます。<br/>
これで、起動時にこのスクリプトがスタートするようになるはずです。</p>

<h2>再起動と動作確認</h2>

<p>ここまで来たら再起動させてみます。これでリセット用のGPIOの監視プロセスが起動されているはずです。</p>

<p>そして、GPIO23をGNDに落としてみます。
見事シャットダウンされました！</p>

<p>めでたし。</p>

<p>今回、init.dの使い方もちょっぴり勉強出来ました。</p>

<h5>2015/2/11 追記：</h5>

<h5>システム組み込み用としては、シャットダウンしたあとに自動で電源を切るような回路がほしいところです。</h5>

<h5>このとき問題なのは、どの時点で電源を切ればいいかということです。システムはダウンしてしまっているので、ソフトウエアは関与できません。システムが終了したら状態が変化するどこかの端子の電圧をモニタして、そこが変化したら切る、というような事をしないといけません。さてどこを見ればいいか。</h5>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebCamをつなげてみる]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/25/webcam/"/>
    <updated>2015-01-25T09:20:05+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/25/webcam</id>
    <content type="html"><![CDATA[<p>今回はwebカムの接続を試して見ました。いろいろ話を聞いていると、データロガーが提示するデータだけでは情報が足りない、ということが多かったです。せっかくオンラインにするなら、写真とか「雰囲気」を伝えてくれるとありがたい、という意見が多かったです。言われてみれば、データだけなら今までのシステムでもできるし、とおもいましたので絵も転送できるようなケイパビリティを持たせたいなと思った次第。</p>

<!-- more -->


<p>webカムはRaspberry Piに接続できるのかどうか調べてみると、意外と簡単に接続できそうです。一昔前は結構苦労していたように感じたので、時代は進んだなあと。</p>

<p>で、キャプチャするソフトをリストアップしてみると。</p>

<ul>
<li>fswebcam　スチル撮影</li>
<li>motion　画像の変化を検出して記録</li>
<li>guvcview 動画のキャプチャ（GUI必要？）</li>
</ul>


<p>と言ったところが皆さんに使われているようです。特に監視カメラ用途ではmotionが便利そうです。</p>

<p>今回は、能動的にシャッターを切って記録する用途ですので、fswebcamを使うことにしました。</p>

<hr />

<h3>USBカメラを接続してみる</h3>

<p>とりあえずUSBカメラを何も考えずRaspberry Piにつないでみます。</p>

<p>認識されているか確認してみると</p>

<pre><code class="sh UBS device list">$ lsusb
Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. 
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. 
Bus 001 Device 006: ID 046d:080a Logitech, Inc. Portable Webcam C905
</code></pre>

<p>こんなかんじで認識されています。</p>

<p>次に、fswebcamをインストール。参考にしたのは<a href="http://www.raspberrypi.org/documentation/usage/webcams/">こちら</a></p>

<p>続けて試し撮りなどしてみます。</p>

<pre><code class="sh install fswebcam">$ sudo apt-get install fswebcam

$ fswebcam -v   #こうすると色々教えてくれます。
--- Opening /dev/video0...
Trying source module v4l2...
/dev/video0 opened.
src_v4l2_get_capability,87: /dev/video0 information:
src_v4l2_get_capability,88: cap.driver: "uvcvideo"
src_v4l2_get_capability,89: cap.card: "UVC Camera (046d:080a)"
src_v4l2_get_capability,90: cap.bus_info: "usb-bcm2708_usb-1.4"
src_v4l2_get_capability,91: cap.capabilities=0x84000001
src_v4l2_get_capability,92: - VIDEO_CAPTURE
src_v4l2_get_capability,103: - STREAMING
No input was specified, using the first.
src_v4l2_set_input,181: /dev/video0: Input 0 information:
src_v4l2_set_input,182: name = "Camera 1"
src_v4l2_set_input,183: type = 00000002
src_v4l2_set_input,185: - CAMERA
src_v4l2_set_input,186: audioset = 00000000
src_v4l2_set_input,187: tuner = 00000000
src_v4l2_set_input,188: status = 00000000
src_v4l2_set_pix_format,541: Device offers the following V4L2 pixel formats:
src_v4l2_set_pix_format,554: 0: [0x56595559] 'YUYV' (YUV 4:2:2 (YUYV))
src_v4l2_set_pix_format,554: 1: [0x47504A4D] 'MJPG' (MJPEG)
Using palette MJPEG
Adjusting resolution from 384x288 to 352x288.
src_v4l2_set_mmap,693: mmap information:
src_v4l2_set_mmap,694: frames=4
src_v4l2_set_mmap,741: 0 length=102400
src_v4l2_set_mmap,741: 1 length=102400
src_v4l2_set_mmap,741: 2 length=102400
src_v4l2_set_mmap,741: 3 length=102400
--- Capturing frame...
verify_jpeg_dht,94: Inserting DHT segment into JPEG frame.
Captured frame in 0.00 seconds.
--- Processing captured image...
There are unsaved changes to the image.

$ fswebcam -r 1000 ./test.jpg
--- Opening /dev/video0...
Trying source module v4l2...
/dev/video0 opened.
No input was specified, using the first.
Adjusting resolution from 1000x-1 to 960x720.
--- Capturing frame...
Captured frame in 0.00 seconds.
--- Processing captured image...
Writing JPEG image to './test.jpg'.
</code></pre>

<p>上の例では解像度1000pxぐらいの絵をとってtest.jpgで保存してもらう例です。実際にはカメラの撮影可能な解像度に適宜調整されるようです。</p>

<p>撮影したのはいいですが、このままでは本当にとれているのか絵を觀ることができないので判りません。scpなどのコマンドで転送してもいいですが、すぐにMQTTで転送することを考えなきゃいけないので、とりあえず手動でmosquittoを使って転送してみます。</p>

<p>プロトコルとしては、どんなファイルでも（中身に関係なく）送れるのですが、mosquittoはコマンドラインということもあり、メッセージをサブスクライブしたときペイロードの内容を出力したあと改行コードを出力してしまいます。文字情報の時は便利なのですが、バイナリのときはちょっと厄介です。<br/>
それを抑止するために-N オプションがあり、これを使うとバイナリファイルも比較的扱いやすくなるはずです。</p>

<p>これを試してみます。</p>

<pre><code class="sh binary file subscription via MQTT">#サブスクライブ側を用意
$ mosquitto_sub -N -h MY.BROKER -t MY/DEVICE/photo &gt; test.jpg

#写真をとったエッジデバイス側でファイルまるごとパブリッシュ
$ mosquitto_pub -h MY.BROKER -t MY/DEVICE/photo -f ./test.jpg
</code></pre>

<p>このあと、サブスクライブ側をCtrl−Cで中断して、サブスクライブしたtest.jpgを確認してください。</p>

<p>手動で中断しないといけないのが、イマイチですが一応転送はできます。</p>

<p>スクリプトによる写真データのサブスクリプションは、mosquitto_subでは対処しきれない感じがします。
ここは、paho版の出番になりそうですね。(もちろん、mosquittoのライブラリをつかってCで書いてもいいのですけど、わたしはCができませんので。。。。)</p>

<h2>おまけ</h2>

<p>このままじゃあまり役立たないので、webサーバを動かして写真を配信する設定を試して見ました。
こちらの<a href="http://nofx2.txt-nifty.com/it/2013/07/raspberry-pi-ng.html">ページ</a>丸写しです。ありがとうございます。</p>

<p>webサーバにはいまどきの、nginxを選びました。apacheは昔苦労した記憶があり、めんどくさいし時間がかかりそうというイメージでしたので今時流行りを。</p>

<pre><code class="sh install nginx"># Nginxインストール
$ sudo apt-get install nginx
# 1.2.1-2.2+wheezy3がインストールされました。

# web page 用ディレクトリの作成
$ cd ~
$ mkdir www

# Nginxの設定の変更
$ sudo vi /etc/nginx/sites-available/default
# 設定フアイルは/etc/nginx/nginx.confにもありますが、
#　ここらへんの使い分けはよくわかっていません。
# server {　}
#   の中にある公開するweb pageディレクトリを先ほど作ったディレクトリに変更します

    #root /usr/share/nginx/www;
    root /home/pi/www;


# サイトを有効にするため、シンボリックリンクを張る。
$ sudo ln -s /etc/nginx/sites-available/pi /etc/nginx/sites-enabled/
#  ここらへんは詳細不明です。
#　多分これがなくても先ほどの設定変更はdefaultに対して行ったので、
#　有効になると思います。
#　すでに、/etc/nginx/sites-enabled/には
#  /etc/nginx/sites-available/defaultのリンクが置かれていました。

# Nginxの設定ファイルに問題が無いかチェック
$ sudo nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

# Nginx再起動
$ sudo service nginx restart

# 自動起動設定
$ sudo update-rc.d nginx defaults

# index.htmlの作成
#　とりあえず、nginxの初期設定のindex.htmlをコピー

cp /usr/share/nginx/www/index.html ~/www/
</code></pre>

<p>ここまでできたら、webサーバにアクセスしてみてください。
なにか反応があるはずです。</p>

<p>次に、とった写真を見れるようにします。</p>

<h3>　写真入りindex.htmlを用意</h3>

<p>&#8220;`sh
$ vi ~/www/index.html
<html>
<head>
<title>Welcome to nginx!</title>
</head>
<body bgcolor="white" text="black"></p>

<center><h1><img src="./test.jpg" alt="test picture" ></h1></center>


<p></body>
</html></p>

<h1>写真をとってwwwディレクトリに入れてみます。</h1>

<p>$ fswebcam ~/www/test.jpg
&#8220;`</p>

<p>ここでwebをアクセスすると写真が見えるはずです。</p>

<p>一段落。</p>

<p>さて、このファイルはフラッシュメモリ上に展開されているので、あまり派手に何回もとっては消しをすると、あっという間にフラッシュメモリが使えなくなります。そこで、ramdiskを写真の置き場に使うことにします。
webサーバは指定したwebページ保存場所以外のファイルは読めないようなので、最初にramdisk上の写真ファイルのリンクをwwwディレクトリ上に作っておきます。</p>

<pre><code>$ ln -s /run/shm/picture.jpg ~/www/test.jpg 
# /run/shmのディレクトリはRAM-DISKになっています。

$ fswebcam /run/shm/picture.jpg
#　これでwebページ上の写真が、今撮ったものに変わるはずです。
</code></pre>

<p>ここまで来ると、立派な定点カメラの出来上がり、という感じです。</p>

<p>MQTTのサブスクライバをつければ、シャッタや解像度のコントロールがMQTT経由でできますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自分のIPアドレスを送信する]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/13/ipaddress/"/>
    <updated>2015-01-13T20:43:51+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/13/ipaddress</id>
    <content type="html"><![CDATA[<p>自分のIPアドレスをMQTTで送信してもらうと、デバグの時にIPアドレスをいちいち調べなくていいので楽だなあ、とおもい試して見ました。</p>

<!-- more -->


<p>Raspberry Pi で、まずは、どうやってIPアドレスを抽出するかです。</p>

<p>自分のIPアドレスは<code>ifconfig</code>で出てきますが、これは人間用なのでフォーマットがややこしい。</p>

<pre><code class="sh example of result of "ifconfig" command">$ ifconfig eth0

eth0      Link encap:Ethernet  HWaddr b8:27:eb:29:61:2d  
          inet addr:192.168.0.xyz  Bcast:192.168.0.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:95729 errors:0 dropped:67 overruns:0 frame:0
          TX packets:62090 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:10362519 (9.8 MiB)  TX bytes:6910384 (6.5 MiB)
</code></pre>

<p>色々と悩んだ末、こんな感じのコマンドラインではどうかと。。。。</p>

<pre><code class="sh a example of one-liner extracting IP adress from "ifconfig" command">ifconfig eth0 | grep -o '^ *inet addr:.*B' | grep -E -o '([0-9]{1,3}\.){3}[0-9]{1,3}'
</code></pre>

<p>最初のgrepでインターフェイスのIPアドレスを表示しているフレーズだけを抜き出します。<br/>
具体的には行頭から任意の数のスペースがあって、&#8221;inet addr:&ldquo;とあって、任意の文字が続き&#8221;B&#8221;で終わる部分です。</p>

<p><code>grep -o '^ *inet addr:.*B'</code></p>

<p>次に、そのフレーズの中には1つしかIPアドレスは入っていないはずなので、それを抜き出します。</p>

<p><code>grep -E -o '([0-9]{1,3}\.){3}[0-9]{1,3}'</code></p>

<p>だいたいこれで、行けそうです。
試しにやってみると。</p>

<pre><code class="sh test for the one-liner ">$ ifconfig eth0 | grep -o '^ *inet addr:.*B' | grep -E -o '([0-9]{1,3}\.){3}[0-9]{1,3}'
192.168.0.xyz
</code></pre>

<p>今回の目的には十分かとおもいます。</p>

<p>しかし、なんかもっといい方法（どっかのファイルを見るとか）がありそうなきもします。。。。</p>

<hr />

<h4>2015/02/19 追記</h4>

<blockquote><p>今日、IPアドレスを表示するコマンドを発見しました。</p>

<p><code>$ hostname -I</code></p>

<p>なんで検索しなかったんだろう。。。。</p></blockquote>

<hr />

<p>さて、このコマンドラインをデバイスのスクリプト（cronで動く）にいれてみたところ、うまく動かない。具体的には、結果がNULLになってしまうのです。試しに、手元でコマンドラインから実行するとうまく動く。うう〜ん。<br/>
さっぱり理由が分からず、いろいろ調べてみたところ「<a href="http://higelog.brassworks.jp/?p=1775">動かないときはエラーログを取れ！</a>」という啓示をいただき、試してみたところ、<code>command not found</code>とのこと。ifconfigコマンドへのパスが通ってない、という情けないという状況。言われてみれば確かにそんなことをどこかで見たような気がするなあ。。。。</p>

<p>ということで、ifconfigコマンドを絶対パスで指定して事なきを得ました。</p>

<p><strong>「CRONのコマンドは絶対パス指定」</strong>　勉強しました。。。</p>
]]></content>
  </entry>
  
</feed>
