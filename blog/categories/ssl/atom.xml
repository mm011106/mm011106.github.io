<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ssl | MQTT and ...]]></title>
  <link href="http://mm011106.github.io/blog/categories/ssl/atom.xml" rel="self"/>
  <link href="http://mm011106.github.io/"/>
  <updated>2015-11-18T21:10:57+09:00</updated>
  <id>http://mm011106.github.io/</id>
  <author>
    <name><![CDATA[Masakazu Miyamoto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[オレオレ証明書を作ってみようかと　実践3]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/03/ore-ore-certificate4/"/>
    <updated>2015-02-03T19:49:16+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/03/ore-ore-certificate4</id>
    <content type="html"><![CDATA[<p>先の投稿でCAを作って、そのキーで証明書にサインしたサーバ証明書を作りました。が、今日何気なくwebを眺めていると”SHA-1は廃止、これからはSHA-2を使いましょう”というような記事があり、ああそう言えば昨日作った証明書はSHA-1でのハッシュ値だったなあと。</p>

<!-- more -->


<p>ということで、作り直します。</p>

<pre><code>$ sudo openssl genrsa 2048 &gt; CA_private_key.pem
$ sudo openssl req -new -sha256 -key ./CA_private_key.pem -x509 -days 7300 &gt; CA_selfsigned_Certificate.pem
</code></pre>

<p>という感じになりますか。</p>

<pre><code class="">$ sudo openssl x509 -text &lt; CA_selfsigned_Certificate.pem
</code></pre>

<p>で確認してみると、たしかにSHA256でハッシュが作られている、と書いてありました。</p>

<p>これでok。</p>

<blockquote><p>SHA-1は2005年に脆弱性が問題になり、2010年までにSHA-2に移行するように要請されていたようです。で、何が問題かというと、webを読みかじったところによると、SHA-1でつくったハッシュは「あるファイルと同じハッシュになるファイルを作れる時間」が当初思っていたよりも速く（短い時間で）できることがわかったそうで、同じハッシュを持った違うファイルを作ることが比較的簡単に可能になります。そうすると、サインした証明書の中身をすげ替えてもわからない、ということが起こるようです。</p>

<p>ここらへんの周辺事情は検索すると山ほど引っかかるので、読み物としては面白いですね。</p></blockquote>

<p>また、元々の鍵のクオリティを上げる（ランダム性を上げる？）ために、乱数をパラメタとして与える、というのもあるようです。</p>

<pre><code>$ sudo openssl md5 /var/log/syslog* &gt; rand.dat
$ sudo openssl genrsa -rand ./rand.dat -aes256 2048 &gt; CA_private_key.pem  
</code></pre>

<p>と言った感じです。syslogのファイルのMD5ハッシュ値を計算してそれを乱数の種にするように指定します。</p>

<p>さらに、鍵をAES256で暗号化する指定を入れています。</p>

<p>なんか、この暗号の世界はかなりな勢いで世代替わりがあるようですね。現在「最高性能」といわれているものが５年後には「廃止」になっているかもしれないです。
そういう意味でも、数年に一度ぐらいの間隔で証明書を作りなおすのもいいかもしれませんね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オレオレ証明書を作ってみようかと　実践2]]></title>
    <link href="http://mm011106.github.io/blog/2015/02/02/ore-ore-certificate3/"/>
    <updated>2015-02-02T20:41:28+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/02/02/ore-ore-certificate3</id>
    <content type="html"><![CDATA[<p>先の投稿では「オレオレ証明書」を作って、無事nginxに導入してTLS接続が出来るようになりました。<br/>
あとはこれをmosquittoに応用するだけ、と思っていたら実はCA certificate（CA証明書）が必要だと言うことにはたと気づき、がっくり。</p>

<!-- more -->


<p>結局、</p>

<ul>
<li>認証局(CA)を作る</li>
<li>その認証局の鍵でサーバの証明書にサインしてもらう</li>
</ul>


<p>と言う手順をとる必要があります。<br/>
認証局と行っても、自己証明書ということでは先に作ったサーバの証明書と同じです。</p>

<h2>自前のCAを作る</h2>

<p>基本的には、サーバの自己証明書を作るのと同じ手順で認証局の証明書（CA certificate)をつくります。手順としては</p>

<ul>
<li>CAの鍵を作る　(CA key)</li>
<li>自己署名の証明書を作る　（これがCAの証明書（CA certificate)になる）</li>
</ul>


<p>となります。 ここでは、CAの鍵をCA_private_key.pem,　CAの証明書をCA_selfsigned_Certificate.pemというファイル名を付けました。</p>

<p>実は、これがいっぺんにできるそうで、これが以下のコマンド。</p>

<pre><code>$ sudo openssl req -new -x509 -newkey rsa:2048 -keyout CA_private_key.pem -days 7300 &gt; CA_selfsigned_Certificate.pem
</code></pre>

<p>このなかで、</p>

<ul>
<li>鍵を作って</li>
<li>リクエスト用のファイルを作って</li>
<li>それに対して自分でサインして</li>
</ul>


<p>という3つのことが行われているようです。</p>

<p>このコマンドでは、キーを暗号化するためのパスフレーズを要求されます。さらに、証明書に記載するための情報（組織名とか所在地とか）を聞かれますので、適宜答えていきます。</p>

<p>最初、以下の様なコマンドでも良いはずですが、パスフレーズを入力するところがでません。確認してみると、鍵は暗号化されていないようです。</p>

<pre><code>$ sudo openssl genrsa 2048 &gt; CA_private_key.pem
$ sudo openssl req -new -key ./CA_private_key.pem -x509 -days 7300 &gt; CA_selfsigned_Certificate.pem
</code></pre>

<p>manでしらべてみると、genrsaのオプションで -des3とか暗号化のオプションを付けないためパスフレーズを聞かれないようです。暗号化する指示をすればパスフレーズを聞いてきました。理由が分かれば当たり前の話。<br/>
なので、最初の鍵を作るコマンドは</p>

<p><code>$ sudo openssl genrsa -des3 2048 &gt; CA_private_key.pem</code></p>

<p>とするのが、安全性の面でも良い感じですかね。</p>

<p>これでCA鍵とCA証明書ができあがりです。「俺様認証局」ですね。この鍵でいくらでも「オレオレ」証明書がつくれます。</p>

<p>会社内、組織内のセキュア接続のためには有効につかえるかな、とおもいます。ただ鍵が流出するといくら社内用といえどもセキュリティ的に問題があるので、きちんと管理しないといけません。鍵には名前も書いてありますしね。</p>

<h2>サーバの証明書にサインする</h2>

<p>それでは、サーバの証明書を作ってみます。</p>

<p>最初にサーバに設置する証明書のための鍵をつくります。さらに、その鍵をもとに証明書署名リクエストファイルを作成します。まあ、申請書みたいな物ですね。これは、前回の<a href="http://mm011106.github.io/blog/2015/01/31/ore-ore-certificate2/">オレオレ証明書を作ってみようかと　実践１</a>を参考にしてください。この記事の１．２．を実行してもらうといいとおもいます。</p>

<p>ここでは、署名リクエストファイルをmyserver.csr、署名付き証明書をmyserver.crtとします。</p>

<p>サーバの証明書にCAのサインをするので、myserver.csrとCA_selfsigned_Certificate.pem（CA証明書）, CA_private_key.pem（CA鍵）が必要になります。</p>

<p>具体的には、</p>

<pre><code>$ sudo openssl x509 -CA CA_selfsigned_Certificate.pem -CAkey CA_private_key.pem -req -days 7300 -CAcreateserial &lt; myserver.csr &gt; myserver.crt
</code></pre>

<p>とします。ここで、-daysはサインする証明書の有効日数、-CAcreateserialは最初に署名するときだけ必要なオプション。これをやるとシリアル番号のファイルが出来るそうな。</p>

<p>これだけで、サーバの証明書にCAのサインをしてサーバに設定出来る証明書ができあがりました。</p>

<p>nginxに入れて動作を確認しました。</p>

<p>ブラウザから証明書を確認すると、「発行者名」と「サブジェクト名」がそれぞれ、CA証明書を作るときに入力した情報、myserverの証明書（証明書署名リクエストファイル）作るときに入力した情報になっているはずです。</p>

<p>ここでもう少しきちんとしたい人は、CA証明書をブラウザに読み込むことで、「この証明書は不明な機関によって署名されています」的なメッセージを回避できます。この作業はこの証明書を信じます、と言う宣言ですので、もしこの鍵が悪用されたりすると大変なことになる可能性があります。鍵の管理はしっかりしておきましょう。</p>

<p>信じてもらうためにはしっかりと行動するということですね。人生。</p>

<p>mosquittoではブローカがcertificateを提供してくるので、それが正しいかどうか確認するための認証局の証明書が必要になります。webブラウザなんかだと、パブリックな認証局の情報は一通りはいっていますから普段認証局のcertificateを意識することは無いですよね。</p>

<p>きょうは、ここまでです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オレオレ証明書を作ってみようかと　実践１]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/31/ore-ore-certificate2/"/>
    <updated>2015-01-31T20:29:12+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/31/ore-ore-certificate2</id>
    <content type="html"><![CDATA[<p>先に投稿した、オレオレ証明書の続きです。</p>

<p>今回は、実際の証明書を作りwebサーバに導入して動作確認までやって見ました。</p>

<!-- more -->


<h2>オレオレ証明書を作る</h2>

<p>いったいどこから手を付ければ良いか分からないので、検索してみます。
いろいろなところで例が示されていますが、opensslで作れそうな感じです。とくに<a href="http://d.hatena.ne.jp/ozuma/20130511/1368284304">こちらのページ</a>に非常にわかりやすくまとめられていましたので、こちらをそのまま順番に試していこうと思います。</p>

<p>詳しい解説は、そちらをご覧ください。</p>

<h3>1.秘密鍵を作る</h3>

<p>まずは、秘密鍵(server.key)を作ります。</p>

<pre><code class="sh ">$ openssl genrsa 2048 &gt; server.key
</code></pre>

<p>これで2048bitのRSAキーが作られます。参考ページの解説によると、この情報の中に暗号化に必要な全てのものが入っています。ここから公開鍵も作られます。</p>

<p>中身を見てみます。</p>

<pre><code class="sh ">$ openssl rsa -text &lt; server.key 
Private-Key: (2048 bit)
modulus:
  :
  :
</code></pre>

<p>見てもよく分かりませんが、なんか出来てます。</p>

<h3>2.証明書署名リクエストファイルを作る</h3>

<p>次に、証明書にサインしてもらうためのリクエストファイルを作ります。
このファイルには、秘密鍵から作られた公開鍵と秘密鍵のハッシュ値（鍵の情報を要約した物）が入っています。さらに証明書に記載する署名情報（サーバのFQDNとか組織名とか）が加わります。</p>

<pre><code class="sh ">$ openssl req -new -key server.key &gt; server.csr
</code></pre>

<p>このときに、サーバのFQDNや組織名、所在地など聞かれます。適当で良いようですが、サーバのFQDNはきちんと入れておいた方が良いようです。証明書のFQDNとそれを設置したサーバのFQDNが違うのはダメなような気がしますね。</p>

<p>再び内容を確認します。</p>

<pre><code class="sh ">$ openssl req -test &lt; server.csr 
</code></pre>

<h3>3.認証局に成り代わって、証明書にサインします</h3>

<p>できあがった証明書署名リクエストファイルに署名をして正式な証明書にします。<br/>
本来これは認証局がやることですが、「おれおれ」なので「おれ」が証明書にサインします。</p>

<pre><code class="">openssl x509 -req -days 7300 -signkey server.key &lt; server.csr &gt; server.crt
</code></pre>

<p>-days オプションでは有効期限を指定します。ここでは7300日、20年、だいたい私が死ぬまで有効。</p>

<p>できあがりを確認してみます。</p>

<pre><code>$ openssl x509 -text &lt; server.crt 
</code></pre>

<p>先ほど入力した組織名やFQDNが見えてくると思います。</p>

<p>必要なファイルは、.crtファイル（証明書）と.key（秘密鍵）です。
両方ともownをrootにして、パーミッションを600に設定しておきます。</p>

<h2>まずはwebサーバに設定してみる</h2>

<p>先のwebcamの投稿でnginxをインストールしましたが、このサーバに作った鍵を設定して試してみます。</p>

<p>これも、設定方法を検索したところ、そのものずばり<a href="http://heartbeats.jp/hbblog/2012/06/nginx06.html">&ldquo;nginxのTLS設定&rdquo;</a>というページが見つかりました。この連載、とてもわかりやすくnginxの設定方法が書かれていますので、あとでよく勉強しておこうと思います。</p>

<p>やることとしては、configファイルを変更してhttpsの受け口を作り、そこに先ほど作った証明書をいれる、ということになります。</p>

<p>設定ファイルは、先のページを参考に以下の様にしました。</p>

<pre><code class="sh /etc/nginx/sites-sites-available/default">server {
    listen 443 ssl;
    server_name my.www.server.jp;
    root /home/mynginx/www;
    index index.html index.htm;

    ssl_certificate /etc/nginx/server.crt;
    ssl_certificate_key /etc/nginx/server.key;

    ssl_session_timeout 5m;
    ssl_session_cache shared:SSL:10m;

    ssl_protocols SSLv3 TLSv1;
    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv3:+EXP;
    ssl_prefer_server_ciphers on;

    location / {
        try_files $uri $uri/ =404;
        auth_basic "Restricted";
        auth_basic_user_file /etc/nginx/.htpasswd;
    }
}
</code></pre>

<ul>
<li>httpsのポートを443に設定してsslを有効にします。</li>
<li>サーバのFQDNを設定</li>
<li>webサーバのドキュメントルートを設定</li>
<li>証明書と秘密鍵を指定</li>
<li>タイムアウトとキャッシュを設定（ここら辺は参考webページの写しです）</li>
<li>SSLのプロトコル指定と暗号化スイートの指定です。ここら辺はnginxのデフォルト設定ファイルのコピー</li>
<li>ドキュメントの特定の場所のビヘイビアの指定です。ここではルート以下の全てのアクセスでBasic認証を要求するような設定です</li>
</ul>


<p>認証のために.htpasswdが必要になりますが、これはhttp-toolsのなかにあるhtpasswdコマンドでつくりました。</p>

<pre><code class="sh how-to make a password file">$ sudo htpasswd -c .htpasswd UserName
New password:
Re-type new password:
</code></pre>

<p>のようにしてパスワードファイルを作成して、設定します。</p>

<h3>4.設定を有効にして、再起動</h3>

<p>設定を書き終えたら設定を確認して、読み込ませます。</p>

<pre><code class="sh restart nginx">$ sudo nginx -t
$ sudo nginx -s reload
</code></pre>

<h3>5.動作確認</h3>

<p>これで、TLSが有効になっているはずです。アクセスしてみます。</p>

<p><code>https://my.www.server.jp</code></p>

<p>ブラウザからは「この証明書は無効です」などのワーニングが出てきました。証明書に有効なサインがない、サインした人が「ちゃんとした」人じゃ無いので、このようにワーニングがでます。
出てきたワーニングから「証明書を確認する」などのボタンをおして、自分が作った証明書だということを確認します。</p>

<p>確認できたら、ワーニングを無視して進みます。
ここでログイン（Basic認証）のポップアップが出てくるはずです。先ほど設定したログイン名とパスワードを入力します。無事ログインして、webページがみれました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[オレオレ証明書を作ってみようかと　準備]]></title>
    <link href="http://mm011106.github.io/blog/2015/01/18/ore-ore-certificate/"/>
    <updated>2015-01-18T11:28:32+09:00</updated>
    <id>http://mm011106.github.io/blog/2015/01/18/ore-ore-certificate</id>
    <content type="html"><![CDATA[<p>現在、セキュアな通信はSSHで確保する方針ですが、証明書ベースの暗号化についても考えておいてもいいのじゃないかなあとおもい、いわゆる「オレオレ証明書」を試してみようかと思った次第です。
ここでは、まず勉強。</p>

<!-- more -->


<p>英語のwebでは&#8221;self-signed certificate&#8221;なんて言われていますが、日本では「オレオレ詐欺」にちなんで、「オレオレ証明書」と呼ぶのがツウのやりかたのようです。でも、これは結構いいネーミングじゃないかと思います。日本で「オレオレ」というのはかなりダーティな印象があるので、「これ、オレオレ証明書だよね」というと、直感的に騙されそうな感じがします。</p>

<p>昔の記事（2007年頃）ですが、銀行のオンラインバンキングなどでもオレオレ証明の一種が使われていたということで、間違ったITリテラシを教えてしまうという危険が<a href="http://takagi-hiromitsu.jp/diary/20071117.html">指摘</a>されています。</p>

<p>このページの終わりの方には証明書の分類が挙げられており、一口に「オレオレ」といってもいろいろあるのだよ。ということがわかります。</p>

<p>今回つくろうとしているのは、ここで言うところの「第四種オレオレ証明書」です。<br/>
とくに悪意があってself-signedにするわけではなく、パブリックに公開されるサーバではないし、特定の用途にしか使わない、自分たち専用の暗号化経路ということです。</p>

<p>ポリシーとしては、</p>

<ul>
<li>経路の暗号化には証明書ベースの共通鍵暗号化</li>
<li>ログイン制御にはユーザ名/パスワード</li>
<li>ポート番号の変更</li>
</ul>


<p>という3本柱で考えてみたいと思います。</p>

<p>証明書ベースの認証を行うという事は、だれでも（ポート番号がわかれば）暗号化経路を作れる、ということになります。そのため、実際にブローカに接続できるかどうかは、ユーザ名による認証を行う必要があると思ったからです。実際には、IPやドメイン名の制限など、可能な接続制限を取る必要があると思います。</p>

<h2>mosquitto.conf と mosquitto_pub/subの暗号化についての記載</h2>

<p>まずは、いま使っているクライアント・サーバアプリケーションが証明書ベースの暗号化にどのように対応しているかを確認しておきます。
まずは、ブローカ側の<code>mosquitto.conf</code>から</p>

<h3>mosquitto.conf</h3>

<h4>Authentication</h4>

<blockquote><p>The authentication options described below allow a wide range of possibilities in conjunction with the listener options. This section aims to clarify the possibilities.</p>

<p>以下に示す認証のオプションはリスナーのオプションとともに活用することで広いレンジの可能性を提供します。このセクションはその可能性を明らかにします。</p>

<p>The simplest option is to have no authentication at all. This is the default if no other options are given. Unauthenticated encrypted support is provided by using the certificate based SSL/TLS based options cafile/capath, certfile and keyfile.</p>

<p>最もシンプルなものは認証をしないようにすることです。これは他のオプションが与えられない限り、デフォルトの設定になります。認証なしの暗号化はcafile/capathオプションにより証明書ベースのSSL/TLSから提供されます。</p>

<p>MQTT provides username/password authentication as part of the protocol. Use the password_file option to define the valid usernames and passwords. Be sure to use network encryption if you are using this option otherwise the username and password will be vulnerable to interception.</p>

<p>MQTTはプロトコルの一部としてユーザ名／パスワードによる認証を提供しています。
<code>password_file</code>オプションを使うことで有効なユーザ名とパスワードを設定できます。このオプションを使うときは経路の暗号化を必ず実施してください。そうしないとユーザ名／パスワードは盗聴の対象となってしまいます。</p>

<p>When using certificate based encryption there are two options that affect authentication. The first is require_certificate, which may be set to true or false. If false, the SSL/TLS component of the client will verify the server but there is no requirement for the client to provide anything for the server: authentication is limited to the MQTT built in username/password. If require_certificate is true, the client must provide a valid certificate in order to connect successfully. In this case, the second option, use_identity_as_username, becomes relevant. If set to true, the Common Name (CN) from the client certificate is used instead of the MQTT username for access control purposes. The password is not replaced because it is assumed that only authenticated clients have valid certificates. If use_identity_as_username is false, the client must authenticate as normal (if required by password_file) through the MQTT options.</p>

<p>証明書ベースの暗号化を行う場合、2つのオプションが認証に影響を与えます。<br/>
1つめは<code>require_certificate</code>で、trueもしくはfalseに設定できます。<br/>
falseの場合、クライアントのSSL/TLSコンポーネントはサーバが正確であるかどうかを確かめます。しかし、クライアントは何もサーバに提供する必要はありません。認証はMQTTにビルトインされたユーザ名・パスワードに制限されます。<br/>
trueの場合、クライアントは有効な証明書を接続するために提供する必要があります。</p>

<p>このケースでは2つ目のオプション、<code>use_identity_as_username</code>が関連してきます。<br/>
これをtrueにセットするとアクセスコントロールのために証明書共通名(CN)がMQTTのユーザ名の代わりに使われます。パスワードは、認証取得をしたユーザのみが有効な証明書を持っていると考えているため変更されません。<br/>
<code>use_identity_as_username</code>がfalseの場合、クライアントは通常と同じようにMQTTによって認証されます。（password_fileが必要です）</p>

<p>When using pre-shared-key based encryption through the psk_hint and psk_file options, the client must provide a valid identity and key in order to connect to the broker before any MQTT communication takes place. If use_identity_as_username is true, the PSK identity is used instead of the MQTT username for access control purposes. If use_identity_as_username is false, the client may still authenticate using the MQTT username/password if using the password_file option.
（ここは事前共有キーの話なのでパス）</p>

<p>Both certificate and PSK based encryption are configured on a per-listener basis.</p>

<p>この証明書ベース、PSKベースの暗号化どちらの場合でもリスナー単位での設定になります。</p>

<p>Authentication plugins can be created to replace the password_file and psk_file options (as well as the ACL options) with e.g. SQL based lookups.</p>

<p>たとえば、SQLデータベース参照などの認証プラグインを、ユーザ名／パスワード認証とPSKファイルのオプションをリプレイスするために設定することも可能です。</p>

<p>It is possible to support multiple authentication schemes at once. A config could be created that had a listener for all of the different encryption options described above and hence a large number of ways of authenticating.</p>

<p>また複数の認証スキームを一度にサポートするようにすることも可能です。設定ファイルは一つのリスナーに対して上記にあるすべての違った暗号化のオプション、つまりいくつもの認証方法を設定することも可能です。</p></blockquote>

<p>と、ここまでの説明では、「いろんな方法で暗号化、認証ができます」というところだけしかわかりませんでした。<br/>
これからやろうとしている証明書ベースの暗号化では、認証と絡めることもできるし、それとは別にすることもできる、というところでしょうか。</p>

<p>証明書をクライアントが提供するようなやり方もできるように読めます。
確かに、クライアントが証明書を提示するという方が理にかなっているかもしれません。今想定しているような構成では、接続してきたクライアントが「偽物」である可能性を排除したいわけで、一般的なHTTPプロトコルでの証明書のようにサーバ側の真贋をユーザのセキュリティのために提供するのとは全く逆になります。</p>

<p>兎にも角にも手を動かさないことには勉強できないので、まずは、証明書をサーバが提供するという、一般的なやり方の設定をしてみようと思います。証明書ベースの暗号化経路を確立、次にユーザ名／パスワードでクライアント認証をする、という手順になります。</p>

<p>今日のところは、これまで。</p>
]]></content>
  </entry>
  
</feed>
